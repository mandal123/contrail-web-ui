/*
 * Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
 */

//@@ sourceURL=tenant_monitor_network.js

var durationStr = ' (last 30 mins)';
var durationTitle = 'Last 30 mins';
var timerId;
var elements;
//var nodesInTopo=new Array();
//var nodes_project=new Array();
var TOP_IN_LAST_MINS = 10;
var NUM_DATA_POINTS_FOR_FLOW_SERIES = 240;
var ENABLE_PEER_CLICK = 1;
var ENABLE_PORT_CLICK = 1;
var ENABLE_FLOW_CLICK = 1;
//var flowCellConfig = {port:{name:'port'},peer:{name:'peer'},flow:{name:'flow'}};
var flowCellConfig = {port:{},peer:{},flow:{}};

function constructReqURL(obj) {
    var url = "";
    var length = 0;
    if(obj['fqName'] != null)
        length = obj['fqName'].split(':').length;
    else
        obj['fqName'] = "*";
    var context = obj['context'];
    //Decide context based on fqName length
    if((context == null) && (length > 0)) {
        var contextMap = ['domain','project'];
        context = contextMap[length-1];
    }

    if(obj['type'] == 'flowdetail') {
        url = "/api/tenant/networking/network/flows"
    }
    //Pickup the correct URL in this if loop
    if(obj['type'] == 'portdetail' && obj['widget'] == 'flowseries') {
        url = "/api/tenant/networking/network/flow-series/port"
    } else if(context == 'domain') {
        url = "/api/tenant/networking/domain/stats/top"
        if(obj['type'] == 'summary') 
            url = "/api/tenant/networking/domain/summary"
    } else if(context == 'project') {
        url = "/api/tenant/networking/project/stats/top"
        if(obj['type'] == 'summary') 
            url = "/api/tenant/networking/project/summary"
        else if(obj['type']=='portRangeDetail') 
            url="/api/admin/reports/query";
    } else if(context == 'network') {
        url = "/api/tenant/networking/network/stats/top"
        if(obj['type']=='portRangeDetail') 
            url="/api/admin/reports/query";
        var urlMap = {  summary: '/api/tenant/networking/vn/summary',
                        flowseries:'/api/tenant/networking/flow-series/vn',
                        details:'/api/tenant/networking/network/details'
                    }
        if(ifNull(obj['widget'],obj['type']) in urlMap)
            url = urlMap[ifNull(obj['widget'],obj['type'])];
    } else if(context == 'connected-nw') { 
        url = "/api/tenant/networking/network/connected/stats/top"
        var urlMap = {  flowseries:'/api/tenant/networking/flow-series/vn',
                        summary:'/api/tenant/networking/network/connected/stats/summary'
                    }
        if(ifNull(obj['widget'],obj['type']) in urlMap)
            url = urlMap[ifNull(obj['widget'],obj['type'])];
    } else if(context == 'instance') { //Instance
        url = "/api/tenant/networking/vm/stats/top"
        var urlMap = {  flowseries:'/api/tenant/networking/flow-series/vm',
                        summary:'/api/tenant/networking/vm/stats/summary'
                    }
        if(ifNull(obj['widget'],obj['type']) in urlMap)
            url = urlMap[ifNull(obj['widget'],obj['type'])];
    } 
    //End - pick the correct URL
    if((obj['type'] == 'instance') && (obj['context'] != 'instance')) {
        url = "/api/tenant/networking/virtual-machines"
    }
    //If need statistics from the beginning
    if(obj['source'] == 'uve') {
        if($.inArray(obj['type'],['project','network']) > -1)
            url = '/api/tenant/networking/virtual-network/summary'
    }
    var reqParams = {
    };
    //No time range required as summary stats are from the beginning
    if(obj['type'] != 'summary') {
        //Retrieve only top 5 if it's not the entire list
        //Exclude list where limit is not applicable
        if($.inArray(obj['view'],['list','flowseries']) == -1) {
            if(obj['widget'] != 'flowseries')
                obj['limit'] = ifNull(obj['limit'],5); 
        }
        //Time-related queries
        if(obj['fromUTC'] != null) {
        } else if(obj['time'] == null) {
            obj['time'] = '10m';
        }
        if(obj['time'] != null) {
            var startEndUTC = getFromToUTC(obj['time']);
            delete obj['time'];
            obj['fromUTC'] = startEndUTC[0];
            obj['toUTC'] = startEndUTC[1];
        }
        $.extend(reqParams,{minsSince : TOP_IN_LAST_MINS});
    }
    if(obj['limit'] != null)
        $.extend(reqParams,{limit:obj['limit']});
    else 
        $.extend(reqParams,{limit:100});    //Hack

    //Rename fqName variable as per NodeJS API requirement 
    if(obj['fqName'] != null) {
        //For flow-series,need to pass fqName as srcVN
        if(context == 'connected-nw') {
            $.extend(reqParams,{'srcVN':obj['srcVN'],'destVN':obj['fqName']});
        } else if(obj['widget'] == 'flowseries') {
            if(context == 'instance') {
                $.extend(reqParams,{'fqName':ifNull(obj['vnName'],obj['fqName']),'ip':obj['ip']});
            } else 
                $.extend(reqParams,{'fqName':obj['fqName']});        //change queryParameter to fqName
        } else if(obj['type'] == 'details') {
            if(context == 'network')
                $.extend(reqParams,{'uuid':obj['uuid']});
        } else if(context == 'instance') {
            $.extend(reqParams,{'fqName':obj['vnName'],'ip':obj['ip']});
        } else
            $.extend(reqParams,{'fqName':obj['fqName']});
    }

    //If port argument is present,just copy it..arguments that need to be copied to reqParams as it is
    $.each(['port','protocol','vmName','vmVnName'],function(idx,field) {
        if(obj[field] != null) {
            //$.extend(reqParams,{port:obj[field]});
            reqParams[field] = obj[field];
        }
    });
    if(obj['type']=='portRangeDetail') {
        var fqName=obj['fqName'],protocolCode;
        reqParams['timeRange']=600;
        reqParams['table']='FlowSeriesTable';
        reqParams['fromTimeUTC']=new XDate().addMinutes(-10).getTime();
        reqParams['toTimeUTC']=new XDate().getTime();
        var protocolMap = {tcp:6,icmp:1,udp:17};
        var protocolCode = [];
        $.each(obj['protocol'],function(idx,value) {
            protocolCode.push(protocolMap[value]);
        });
        /*
        if(protocolMap[obj['protocol']] != null)
            protocolCode = [protocolMap[obj['protocol']]];
        else
            protocolCode = [6,1,17];
        */
        //protocolCode = protocolMap[obj['protocol']];
        if(fqName.split(':').length==2) {
            fqName+=':*';//modified the fqName as per the flow series queries
        }
        var portType = obj['portType'] == 'src' ? 'sport' : 'dport';
        var whereArr = [];
        $.each(protocolCode,function(idx,currProtocol) {
            whereArr.push(kendo.format("({3}={0} AND sourcevn={1} AND protocol={2})",obj['port'],fqName,currProtocol,portType));
        });
        if(obj['portType']=='src'){
            if(fqName.indexOf('*')>-1)
                reqParams['select']="sourcevn, destvn, sourceip, destip, protocol, sport, dport, sum(bytes), sum(packets)";
            else
                reqParams['select']="destvn, sourceip, destip, protocol, sport, dport, sum(bytes), sum(packets)";
            //reqParams['where']=kendo.format("(sport={0} AND sourcevn={1} AND protocol={2})",obj['port'],fqName,protocolCode);
            reqParams['where']=whereArr.join(' OR ');
        }else if(obj['portType']=='dst'){
            if(fqName.indexOf('*')>-1)
                reqParams['select']="sourcevn, destvn, sourceip, destip, protocol, sport, dport, sum(bytes), sum(packets)";
            else
                reqParams['select']="destvn, sourceip, destip, protocol, sport, dport, sum(bytes), sum(packets)";
            //reqParams['where']=kendo.format("(dport={0} AND sourcevn={1} AND protocol={2})",obj['port'],fqName,protocolCode);
            reqParams['where']=whereArr.join(' OR ');
        }
        delete reqParams['fqName'];
        delete reqParams['protocol'];
    }
    //Strip-off type if not required
    if(obj['type'] != null && ($.inArray(obj['type'],['summary','flowdetail','portRangeDetail']) == -1) && 
            ($.inArray(obj['widget'],['flowseries']) == -1))
        $.extend(reqParams,{type:obj['type']});

    //Specific
    if(obj['type'] == 'flowdetail') {
        var fields = ['sourcevn','destvn','protocol','sport','dport','sourceip','destip'];
        reqParams = {};
        $.each(fields,function(idx,field) {
            reqParams[field] = obj[field];
        });
        reqParams['minsSince'] = TOP_IN_LAST_MINS;
        reqParams['limit'] = 100;
    }

    //Add extra parameters for flowseries
    if(obj['widget'] == 'flowseries') {
        $.extend(reqParams,{'sampleCnt':NUM_DATA_POINTS_FOR_FLOW_SERIES});
        $.extend(reqParams,{'minsSince':30});
    }

    //Always send the startTime and endTime instead of minsSince
    if(reqParams['minsSince'] != null) {
        reqParams['endTime'] = new Date().getTime();
        reqParams['startTime'] = new Date(new XDate().addMinutes(-reqParams['minsSince'])).getTime();
        //delete reqParams['minsSince'];
    }

    //Strip-off limit & minsSince if not required
    if(((obj['type'] == 'instance') && (obj['context'] != 'instance')) || (obj['source'] == 'uve') || obj['type'] == 'portRangeDetail') {
        delete reqParams['limit'];
        delete reqParams['minsSince'];
        delete reqParams['endTime'];
        delete reqParams['startTime'];
    }
    if(obj['source'] == 'uve') {
        if(obj['type'] != 'instance') {
            delete reqParams['fqName'];
            if(obj['fqName'] == '' || obj['fqName'] == '*')
                reqParams['fqNameRegExp'] = '*';
            else
                reqParams['fqNameRegExp'] = '*' + obj['fqName'] + ':*';
        } else {
            reqParams['fqName'] = '';
        }
    }

    if((obj['portType'] != null) && (obj['port'].toString().indexOf('-') > -1)) {
        //As NodeJS API expects same URL for project & network and only fqName will be different
        if(url.indexOf('/top') > -1) {
            url = '/api/tenant/networking/network/stats/top';
            reqParams['portRange'] = obj['port'];
            delete reqParams['startTime'];
            delete reqParams['endTime'];
            delete reqParams['port'];
        }
    }
    //reqParams['limit'] = 100;
    delete reqParams['limit'];

    return url + '?' + $.param(reqParams);
}

//str will be [0-9]+(m|h|s|d)
//Returns an array of current time and end time such that the difference beween them will be given str
function getFromToUTC(str) {
    var startDt = new XDate(true);
    var endDt = new XDate(true);
    var fnMap = {d:'addDays',m:'addMinutes',s:'addSeconds',h:'addHours'}
    var unit = str.charAt(str.length-1);
    var value = parseInt(str);
    //If unit is not specified,take it as secs
    if($.inArray(unit,['d','m','s','h']) == -1)
        unit = 's';
    endDt[fnMap[unit]](value);
    return [startDt.getTime(),endDt.getTime()];
}

var portColumns = [{
        field:'name',
        title:'Port',
        template: cellTemplate($.extend({cellText:'#= formatPortName(data)#',tooltip:true,name:'port'},flowCellConfig['port'])),
    },{
        field:'protocol',
        title:'Protocol',
        template:'#= formatProtocol(protocol)#'
    },{
        field:'inBytes',
        title:'Traffic In',
        template:'#= formatBytes(inBytes) #'
    },{
        field:'outBytes',
        title:'Traffic Out',
        template:'#= formatBytes(outBytes) #'
    }];
    var peerColumns = [{
        field:'network',
        title:'Network',
        template: cellTemplate({cellText:'#= formatNetworkName(data)#',tooltip:true,name:'network'}),
    },{
        field:'name',
        title:'Peer IP',
        template: cellTemplate($.extend({cellText:'#= formatPeerName(data)#',tooltip:true,name:'peer'},flowCellConfig['peer'])),
    },{
        field:'inBytes',
        title:'Traffic In',
        template:'#= formatBytes(inBytes) #'
    },{
        field:'outBytes',
        title:'Traffic Out',
        template:'#= formatBytes(outBytes) #'
}];

function ObjectListView() {
    //Context & type 
    this.load = function(obj) {
        var listTemplate = kendo.template($("#list-template").html());
        var context = obj['context'];
        //If context is all,set fqName = *
        var objectType = obj['type'];
        if(objectType == 'flowdetail') {
            layoutHandler.setURLHashParams(obj,{merge:false,triggerHashChange:false});
        } else if(context == 'instance') {
            layoutHandler.setURLHashParams({fqName:obj['fqName'],view:'list',type:obj['type'],context:obj['context'],ip:obj['ip'],vnName:obj['vnName']},
                {p:'mon_net_instances',merge:false,triggerHashChange:false});
        } else if(obj['selector'] != null)  {
        } else 
            layoutHandler.setURLHashParams({fqName:obj['fqName'],view:'list',type:obj['type'],source:obj['source'],context:obj['context']},{merge:false,triggerHashChange:false});
        if(objectType == 'network') {
            obj['detailParseFn'] = parseNetworkDetails;
            if((obj['fqName'] == null) || (obj['fqName'] == '') || obj['fqName'] == '*')
                obj['title'] = kendo.format('Networks Summary');
            else
                obj['title'] = kendo.format('Networks Summary for {0} ({1})',capitalize(context),obj['fqName'].split(':').pop());
            if((obj['source'] != null) && obj['source'] == 'uve')
                obj['subTitle'] = '';
            columns = [{
                field:'name',
                title:'Network',
                template: cellTemplate({cellText:'name',tooltip:true,name:'network'}),
                searchable: true
            },{
                field:'instCnt',
                title:'Instances',
            },{
                field:'inBytes',
                title:'Traffic (In/Out)',
                template:'#= kendo.format("{0} / {1}",formatBytes(inBytes),formatBytes(outBytes)) #'
            },{
                field:'outBytes',
                title:'Throughput (In/Out)',
                template:'#= formatThroughput(inThroughput) #' + ' / ' + '#= formatThroughput(outThroughput) #'
            }];
        } else if(objectType == 'instance') { 
            //obj['title'] = kendo.format('Instances Summary for {0} ({1})',capitalize(context),obj['fqName'].split(':').pop());
            obj['title'] = 'Instances Summary';
            obj['subTitle'] = '';
            obj['detailParseFn'] = parseInstDetails; 
            columns = [{
                field:'name',
                title:'Instance',
                template: cellTemplate({cellText:'vmName',tooltip:true,name:'instance'}),
                searchable: true
            },{
                field:'name',
                title:'UUID',
                searchable: true
            },{
                field:'intfCnt',
                title:'Interfaces',
                width:90
            },{
                field:'vRouter',
                title:'vRouter',
                template: cellTemplate({cellText:'vRouter',tooltip:true,name:'vRouter'}),
                width:80
            },{
                field:'ip',
                title:'IP Address',
                template:'#=getMultiValueStr(ip)#',
                width:120
            },{
                field:'floatingIP',
                title:'Floating IP',
                template:'#=getMultiValueStr(floatingIP)#',
                width:120
            },{
                field:'inBytes',
                title:'Traffic (In/Out)',
                template:'#= formatBytes(inBytes) #' + ' / ' + '#= formatBytes(outBytes) #'
            }];
            if((context == null) || (context == '') || (context == 'project')) {
                columns.splice(2,0,{
                    field:'vn',
                    title:'Virtual Network',
                    template:'#=getMultiValueStr(vn)#',
                    searchable:true
                });
            }
        } else if(objectType == 'project') {
            if(obj['fqName'] == null || obj['fqName'] == '' || obj['fqName'] == '*')
                obj['title'] = kendo.format('Projects Summary');
            else
                obj['title'] = kendo.format('Top Projects for Domain ({0})',obj['fqName']);
            if((obj['source'] != null) && obj['source'] == 'uve')
                obj['subTitle'] = '';
            columns = [{
                field:'name',
                title:'Project',
                template: cellTemplate({cellText:'name',tooltip:true,name:'project'}),
                searchable:true
            },{
                field:'vnCount',
                title:'Networks'
            },{
                field:'inBytes',
                title:'Traffic (In/Out)',
                template:'#= kendo.format("{0} / {1}",formatBytes(inBytes),formatBytes(outBytes)) #'
            },{
                field:'outBytes',
                title:'Throughput (In/Out)',
                template:'#= kendo.format("{0} / {1}",formatThroughput(inThroughput),formatThroughput(outThroughput)) #'
            }];
        } else if(objectType == 'port') {
            obj['title'] = kendo.format('Top Ports for {0} ({1})',capitalize(context),obj['fqName']);
            if(context == 'connected-nw') {
                obj['title'] = kendo.format('Top Ports {0}',getConnectedTitleFromContextObj(obj));
            }
            columns = portColumns;
        } else if(objectType == 'peer') {
            obj['title'] = kendo.format('Top Peers for {0} ({1})',capitalize(context),obj['fqName']);
            columns = peerColumns;
            if(context == 'connected-nw') {
                obj['title'] = kendo.format('Top Peers {0}',getConnectedTitleFromContextObj(obj));
            }
        } else if($.inArray(objectType,['flow','flowdetail']) > -1) {
            if(objectType == 'flowdetail') {
                obj['title'] = kendo.format('Flows Summary');
                /*obj['subTitle'] = kendo.format('Traffic Statistics for Source VN {0} Source IP {1} Source Port {2} Destination VN {3}  Destination IP {4} Destination Port {5} Protocol {6}',
                            obj['sourcevn'],obj['sourceip'],obj['sport'],obj['destvn'],obj['destip'],obj['dport'],formatProtocol(obj['protocol']));*/
                obj['subTitle'] = kendo.format('Traffic Statistics for Protocol {6} {0} : {1} : {2}  -> {3} : {4} : {5}',
                            obj['sourcevn'],obj['sourceip'],obj['sport'],obj['destvn'],obj['destip'],obj['dport'],formatProtocol(obj['protocol']));
            } else  {
                obj['title'] = kendo.format('Top Flows for {0} ({1})',capitalize(context),obj['fqName']);
                if(context == 'connected-nw') 
                    obj['title'] = kendo.format('Top Flows {0}',getConnectedTitleFromContextObj(obj));
            }
            columns = [{
                field:'sourcevn',
                title:'Source VN',
                template: cellTemplate({cellText:'sourcevn',tooltip:true,name:'network'}),
            },{
                field:'sourceip',
                title:'Source IP',
                template: cellTemplate($.extend({cellText:'sourceip'},flowCellConfig['peer'])),
            },{
                field:'sport',
                title:'Source Port',
                template: cellTemplate($.extend({cellText:'sport'},flowCellConfig['port'])),
            },{
                field:'destvn',
                title:'Destination VN',
                template: cellTemplate({cellText:'destvn',tooltip:true,name:'network'}),
            },{
                field:'destip',
                title:'Destination IP',
                template: cellTemplate($.extend({cellText:'destip'},flowCellConfig['port'])),
            },{
                field:'dport',
                title:'Destination Port',
                template: cellTemplate($.extend({cellText:'dport'},flowCellConfig['port'])),
            },{
                field:'protocol',
                title:'Protocol',
                template:'#= formatProtocol(protocol)#'
            },{
                field:'bytes',
                title:'Total Bytes',
            },{
                field:'pkts',
                title:'Total Pkts',
            }];
        }
        var listContainer;
        if(obj['selector'] == null) 
            listContainer = pageContainer;
        else
            listContainer = obj['selector'];
        $(listContainer).html(listTemplate(obj));
        obj['columns'] = columns;
        obj['context'] = context;
        obj['objectType'] = objectType;
        obj['url'] = constructReqURL(obj);
        var contextObj = getContextObj(obj);
        obj['parseFn'] = chartsParseFn.bind(null,{fqName:obj['fqName'],source:obj['source'],objectType:obj['type'],view:'list'});
        obj['config'] = {searchToolbar: true, widgetGridTitle: obj['title']};
        if(objectType == 'instance') {
            //Keep autoBind as true for Instances page
            if(layoutHandler.getURLHashObj()['p'] != 'mon_net_instances')
                obj['config']['autoBind'] = false;
        }
        $(listContainer).find('.list-view').initListTemplate(obj);
    }
}
var objListView = new ObjectListView();

function statsParseFn(response) {
    //If response in Array,sumup inBytes/outBytes/interVNInBytes/interVNOutBytes across all elements
    var obj = {inBytes:0,outBytes:0,interVNInBytes:0,interVNOutBytes:0};
    if(response instanceof Array) {
        $.each(response,function(idx,value) {
            $.each(['inBytes','outBytes','interVNInBytes','interVNOutBytes'],function(idx,field) {
                obj[field] += parseInt(value[field]);
            });
        });
    } else
        obj = response;
    $.each(obj,function(key,value) {
        if($.inArray(key,['inBytes','outBytes','interVNInBytes','interVNOutBytes']) > -1)
            obj[key] = formatBytes(value);
    });
    return [obj];
}

function formatPortName(data) {
    return ifNull(data['sport'],data['dport']);
}

function formatPeerName(data) {
    return long2ip(ifNull(data['sourceip'],data['destip']));
}

function formatNetworkName(data) {
    return ifNull(data['sourcevn'],data['destvn']);
}

function formatFlowName(data) {
    return data;
}

function filterVNsNotInCfg(uveData,fqName) {
    var filteredVNs = [];
    var cfgVNListURL = '/api/tenants/config/virtual-networks';
    if(fqName == null || fqName == '' || fqName == '*') {
    } else if(fqName.split(':').length == 2)  //Project
        cfgVNListURL += '?tenant_id='  + fqName;
    $.ajax({
            url:cfgVNListURL,
            async:false
    }).done(function(configData) {
        var configVNs = []
        $.each(configData['virtual-networks'],function(idx,obj) {
            configVNs.push(obj['fq_name'].join(':'));
        });
        filteredVNs = $.map(uveData,function(obj,idx) {
            if($.inArray(obj['name'],configVNs) > -1) {
                return obj;
            } else
                return null;
        });
    });
    return filteredVNs;
}

function getVirtualNetworksData(deferredObj,regExp) {
    $.when($.ajax({
            url:'/api/tenant/networking/virtual-network/summary?fqNameRegExp=' + regExp  
            }), $.ajax({
                url:'/api/tenants/config/virtual-networks'
            })).done(function(uveData,configData) {
                var configVNs = [],filteredVNs=[];
                $.each(configData[0]['virtual-networks'],function(idx,obj) {
                    configVNs.push(obj['fq_name'].join(':'));
                });
                if(uveData[0]['value'] != null)
                filteredVNs = $.map(uveData[0]['value'],function(obj,idx) {
                    if($.inArray(obj['name'],configVNs) > -1) {
                        return obj;
                    } else
                        return null;
                });
                deferredObj.resolve(filteredVNs);
            }).fail(function() {
                deferredObj.reject();
            });
}

function getDomainDashboardData(deferredObj) {
    var vnDeferredObj = $.Deferred();
    getVirtualNetworksData(vnDeferredObj,'default-domain:*');
    vnDeferredObj.fail(function() {
        deferredObj.reject();
    });
    vnDeferredObj.done(function(result) {
        var vnArr = [],obj = {},projArr = [];projData = {};
        $.each(result,function(idx,d) {
            obj = {};
            obj['name'] = d['name'];
            obj['project'] = obj['name'].split(':').slice(0,2).join(':');
            obj['intfCnt'] = ifNull(jsonPath(d,'$..interface_list')[0],[]).length;
            obj['vnCnt'] = ifNull(jsonPath(d,'$..connected_networks')[0],[]).length;
            obj['inThroughput'] = ifNull(jsonPath(d,'$..in_bandwidth_usage')[0],0);
            obj['outThroughput'] = ifNull(jsonPath(d,'$..out_bandwidth_usage')[0],0);
            obj['throughput'] = obj['inThroughput'] + obj['outThroughput'];
            obj['x'] = obj['intfCnt'];
            obj['y'] = obj['vnCnt'];
            obj['size'] = obj['throughput']+1;
            obj['type'] = 'network';
            vnArr.push(obj);
        });
        var vnCF = crossfilter(vnArr);
        var projDimension = vnCF.dimension(function(d) { return d.project;});
        $.each(vnArr,function(idx,d) {
            if(!(d['project'] in projData)) {
                projData[d['project']] = {
                        intfCnt : 0,
                        vnCnt   : 0,
                        throughput:0
                    };
            }
            projData[d['project']]['intfCnt'] += d['intfCnt'];
            projData[d['project']]['throughput'] += d['throughput'];
            projData[d['project']]['vnCnt']++;
        });
        $.each(projData,function(key,obj) {
            $.extend(obj,{type:'project',name:key,size:obj['throughput']+1,x:obj['intfCnt'],y:obj['vnCnt']});
            projArr.push(obj);
        });
        deferredObj.resolve({networksData:vnArr,projectsData:projArr});
    });
}


function ObjectSummaryView() {
    var statsDataSource,template;
    var self = this;
    var instViewModel = kendo.observable({
        network:'',
        vRouter:''
    });
    this.load = function(obj) {
        var data = {stats:{},charts:{},grids:{}};
        if($.inArray(obj['type'],['domain','project','network']) > -1) {
            data['stats']['parseFn']  = statsParseFn;
        }
        //Common for Domain & Project
        if($.inArray(obj['type'],['domain','project']) > -1) {
            template = 'summary-template';
            //layoutHandler.setURLHashParams({fqName:obj['fqName']},{merge:false});
            data['stats']['list'] = [
                { lbl : 'Total Traffic In',field:'inBytes'},
                { lbl : 'Total Traffic Out',field:'outBytes'},
                { lbl : 'Inter VN Traffic In',field:'interVNInBytes'},
                { lbl : 'Inter VN Traffic Out',field:'interVNOutBytes'},
            ];
            data['charts']['colCount'] = 2;
        }
        var context = obj['type'];
        var objType = obj['type'];
        data['context'] = context;
        //Domain
        if(objType == 'domain') {
            layoutHandler.setURLHashParams({fqName:obj['fqName']},{merge:false,triggerHashChange:false});
            obj['title'] = kendo.format('Traffic Statistics for Domain ({0})',obj['fqName']);
            data['stats']['url'] = constructReqURL($.extend({},obj,{type:'summary'}));
            //Charts
            /*data['charts']['d'] = [{
                    title:kendo.format('Projects with most throughput',durationStr),
                    link:{view:'list',type:'project',fqName:obj['fqName'],context:context},
                    class:tenantNetworkMonitorView,
                    url:constructReqURL($.extend({},obj,{type:'project'})),
                    objectType:'project'
                },{
                    title:kendo.format('Networks with most throughput',durationStr),
                    class:tenantNetworkMonitorView,
                    link:{view:'list',type:'network',fqName:obj['fqName'],context:context},
                    url:constructReqURL($.extend({},obj,{type:'network'})),
                    objectType:'network'
                },{
                    title:kendo.format('Top Peers',durationStr),
                    url:constructReqURL($.extend({},obj,{type:'peer'})),
                    link:{view:'list',type:'peer',fqName:obj['fqName'],context:context},
                    objectType:'peer'
                },{
                    title :kendo.format('Top Ports',durationStr),
                    url:constructReqURL($.extend({},obj,{type:'port'})),
                    link:{view:'list',type:'port',fqName:obj['fqName'],context:context},
                    objectType:'port'
                }];*/
            data['charts']['id'] = 'domain';
            var domainDeferredObj = $.Deferred();
            getDomainDashboardData(domainDeferredObj);
        } else if(objType == 'project') { //Project
            layoutHandler.setURLHashParams({fqName:obj['fqName']},{p:'mon_net_projects',merge:false,triggerHashChange:false});
            pushBreadcrumb([obj['fqName']]);
            template = 'project-template';
            obj['title'] = kendo.format('Traffic Statistics for Project ({0})',obj['fqName'].split(':').pop());
            //obj['topologyTitle'] = kendo.format('Topology for Project ({0})',obj['fqName'].split(':').pop());
            obj['topologyTitle'] = kendo.format('Connectivity Details');
            data['stats']['url'] = constructReqURL($.extend({},obj,{type:'summary'}));
            data['charts']['d'] = [{
                    title:'Networks with most throughput' ,
                    link:{view:'list',type:'network',fqName:obj['fqName'],context:context},
                    class:tenantNetworkMonitorView,
                    url:constructReqURL($.extend({},obj,{type:'network'})),
                    objectType:'network'
                },{
                    title:'Top Peers',
                    link:{view:'list',type:'peer',fqName:obj['fqName'],context:context},
                    class:tenantNetworkMonitorView,
                    url:constructReqURL($.extend({},obj,{type:'peer'})),
                    objectType:'peer'
                },{
                    title:'Top Ports',
                    link:{view:'list',type:'port',fqName:obj['fqName'],context:context},
                    class:tenantNetworkMonitorView,
                    url:constructReqURL($.extend({},obj,{type:'port'})),
                    objectType:'port'
                },{
                    title :'Top Flows',
                    link:{view:'list',type:'flow',fqName:obj['fqName'],context:context},
                    class:tenantNetworkMonitorView,
                    url:constructReqURL($.extend({},obj,{type:'flow'})),
                    objectType:'flow'
                }];
            data['charts']['id'] = 'project';
			//For Project Topology
			data['topology']={renderFn:function(){drawTopology(obj['fqName'])}}
        } else if(objType == 'network') {  //Network
            layoutHandler.setURLHashParams({fqName:obj['fqName']},{p:'mon_net_networks',merge:false,triggerHashChange:false});
            pushBreadcrumb([obj['fqName']]);
            template = 'network-template';
            data['stats'] = [{},{}];
            data['grids'] = [{},{}];
            var detailURL = constructReqURL($.extend({},obj,{type:'details'}));
            //Summary Stats
            data['stats'][0] = {
                list : [
                    { lbl : 'Total Traffic In',field:'inBytes'},
                    { lbl : 'Total Traffic Out',field:'outBytes'},
                    { lbl : 'Inter VN Traffic In',field:'interVNInBytes'},
                    { lbl : 'Inter VN Traffic Out',field:'interVNOutBytes'}],
                parseFn : statsParseFn,
                url : constructReqURL($.extend({},obj,{type:'summary'}))
            };
            data['stats'][1] = {
                list : [
                    { lbl : 'Total Interfaces',field:'intfCnt'},
                    { lbl : 'Instances',field:'vmCnt'},
                    { lbl : 'ACL Rules',field:'aclRuleCnt'}],
                url :  detailURL,
                parseFn: function(response) {
                    response['intfCnt'] = response['intfList'].length;
                    return [response];
                }
            };

            //Grids
            /*data['grids'][1] = {
                url:'/api/tenant/networking/domain/summary?type=network',
                columns : [{
                    field:name,
                    title:'Partially Connected Networks'
                }]
            };
            data['grids'][0] = {
                url: detailURL,
                columns: [{
                    field:'name',
                    title:'Attached Policies'
                }],
                parseFn: function(response) {
                    return response['policyList'];
                }
            }*/
            
            //Time-series chart
            data['ts-chart'] = {};
            data['ts-chart'] = {
               'url' : constructReqURL($.extend({},obj,{widget:'flowseries'}))
            }

            //Charts
            /*data['charts'] = [];
            data['charts'][0] = {
                    d : [{
                            title:'Top Ports' ,
                            link:{view:'list',type:'port',fqName:obj['fqName'],context:context},
                            class:tenantNetworkMonitorView,
                            url:constructReqURL({context:'network',type:'port',fqName:obj['fqName']}),
                            objectType:'port',
                            //logScale:10
                        },{
                            title:'Top Peers',
                            link:{view:'list',type:'peer',fqName:obj['fqName'],context:context},
                            url:constructReqURL({context:'network',type:'peer',fqName:obj['fqName']}),
                            objectType:'peer'
                        },{
                            title :'Top Flows',
                            link:{view:'list',type:'flow',fqName:obj['fqName'],context:context},
                            url:constructReqURL({context:'network',type:'flow',fqName:obj['fqName']}),
                            objectType:'flow',
                            //logScale:2
                        }],
                    id:'network',
                    colCount:3
            };
            data['charts'][1] = {
                d: [{
                    title:'Connected Networks Traffic Ingress/Egress',
                    //url:constructReqURL({context:'network',type:'port',fqName:obj['fqName']}),
                    url:'/api/tenant/networking/network/connected/stats/details?fqName=' + obj['fqName'],
                    duration:false,
                    objectType:'connected-nw',
                    columns: [{
                        field:'fromIngress',
                        name:'Ingress',
                        color:defColors[0]
                    }//,{
                     //  field:'ingressMisMatch',
                     //  name:'Ingress MisMatch',
                     // color:'red'
                    }//,{
                        field:'fromEgress',
                        name:'Egress',
                        color:defColors[1]
                    }//,{
                     // field:'egressMisMatch',
                     // name:'Egress Mismatch',
                     // color:'red'
                    }//],
                    parseFn: function(response) {
                        var retObj = $.map(response,function(arr,idx) {
                            $.each(arr,function(i,obj) {
                                //Convert to integers
                                $.each(['inBytes','inPkts','outBytes','outPkts'],function(idx,field) {
                                    obj[field] = parseInt(obj[field]);
                                });
                            });
                            return { 
                                name:arr[0]['destVN'],
                                fromIngress:arr[0]['outBytes'], //Bytes sent from Src
                                fromEgress:arr[0]['inBytes'],   //Bytes recieved at Src
                                toIngress:arr[1]['outBytes'],   //Bytes sent from Dst
                                toEgress:arr[1]['inBytes'],     //Bytes received at Dst
                                ingress: Math.min(arr[0]['inBytes'],arr[1]['outBytes']),
                                egress:Math.min(arr[0]['outBytes'],arr[1]['inBytes']),
                                ingressMisMatch : Math.abs(arr[0]['inBytes']-arr[1]['outBytes']),
                                egressMisMatch : Math.abs(arr[0]['outBytes']-arr[1]['inBytes'])
                            }
                        });
                        return retObj;
                    }
                }],
                colCount:1,
                id:'connected-nw'
            }*/
			//For Network Topology
			data['topology']={renderFn:function(){drawTopology(obj['fqName'])}}
        } else if(objType == 'connected-nw') {  //Connected Network
            pushBreadcrumb([obj['fqName'] + ' <-> ' + obj['srcVN']]);
            //Show Ingress/Egress Traffic in different colors
            data['stats'] = {
                'list' : [
                    { lbl : kendo.format('Ingress/Egress from {0} to {1}',obj['srcVN'].split(':').pop(),obj['fqName'].split(':').pop()),field:'toNetwork'},
                    { lbl : kendo.format('Egress/Ingress from {0} to {1}',obj['fqName'].split(':').pop(),obj['srcVN'].split(':').pop()),field:'fromNetwork'}
                ],
                parseFn: function(response) {
                    return [{   
                        'toNetwork': kendo.format("<span class='in'>{0}</span> <span class='seperator'>/</span>" +  
                                " <span class='out'>{1}</span>",formatBytes(response['toNW']['inBytes']),formatBytes(response['toNW']['outBytes'])),
                        'fromNetwork': kendo.format("<span class='out'>{0}</span> <span class='seperator'>/</span>" +  
                                " <span class='in'>{1}</span>",formatBytes(response['toNW']['inBytes']),formatBytes(response['toNW']['outBytes'])) 
                        }]
                }
            }
            layoutHandler.setURLHashParams({fqName:obj['fqName'],srcVN:obj['srcVN']},{p:'mon_net_networks',merge:false,triggerHashChange:false});
            template = 'connected-nw-template';
            data['stats']['url'] = constructReqURL($.extend({},obj,{type:'summary'}));
            data['ts-chart'] = {};
            data['ts-chart']['url'] = constructReqURL($.extend({},obj,{widget:'flowseries'}));
            data['charts']['colCount'] = 3;
            data['charts']['id'] = 'network';
            data['charts']['d'] = [{
                    title:'Top Ports' ,
                    link:{view:'list',type:'port',srcVN:obj['srcVN'],fqName:obj['fqName'],context:'connected-nw'},
                    class:tenantNetworkMonitorView,
                    url:constructReqURL({context:'connected-nw',type:'port',fqName:obj['fqName'],srcVN:obj['srcVN']}),
                    objectType:'port'
                },{
                    title:'Top Peers',
                    link:{view:'list',type:'peer',fqName:obj['fqName'],srcVN:obj['srcVN'],context:'connected-nw'},
                    url:constructReqURL({context:'connected-nw',type:'peer',fqName:obj['fqName'],srcVN:obj['srcVN']}),
                    objectType:'peer'
                },{
                    title :'Top Flows',
                    link:{view:'list',type:'flow',fqName:obj['fqName'],srcVN:obj['srcVN'],context:'connected-nw'},
                    url:constructReqURL({context:'connected-nw',type:'flow',fqName:obj['fqName'],srcVN:obj['srcVN']}),
                    objectType:'flow'

                }];
        } else if(objType == 'instance') {  //Instance
            layoutHandler.setURLHashParams({vmName:obj['vmName'],fqName:obj['fqName'],srcVN:obj['srcVN']},{p:'mon_net_instances',merge:false,triggerHashChange:false});
            pushBreadcrumb([obj['vmName']]);
            template = 'inst-template';
            obj['title'] = kendo.format("Traffic Statistics",obj['fqName'],obj['srcVN'].split(':').pop()); 
            data['stats'] = [{},{}];
            data['stats'][0] = {
                'list' : [
                    { lbl : 'Traffic In',field:'toNetwork' },
                    { lbl : 'TrafficOut',field:'fromNetwork',cls:'out' }
                ],
                url:function() {
                    return getInstanceURL($.extend({},obj,{context:'instance',type:'summary'}));
                },
                parseFn:function(response) {
                    return [{   
                        'toNetwork': formatBytes(response['in_bytes']) ,
                        'fromNetwork': formatBytes(response['out_bytes']) 
                        }]
                }
            }
            data['stats'][1] = {
                'list' : [
                    { lbl : 'Network',field:'network' },
                    { lbl : 'vRouter',field:'vRouter'}
                ],
                viewModel:instViewModel
            }
            data['grids'] = {
                url:'/api/tenant/networking/vm/ip-list?vmName=' + obj['fqName'],
                columns : [{
                    field:'fip_ip',
                    title:'Floating IPs'
                }],
                parseFn: function(response) {
                    response = $.map(response['fipList'],function(obj,idx) {
                        obj['fip_ip'] = kendo.format('{0} ({1})',obj['ip_address'],obj['virtual_network']);
                        return obj;
                    });
                    return response;
                }
            };
            data['ts-chart'] = {};
            data['ts-chart']['url'] = function() {
                return getInstanceURL($.extend({},obj,{context:'instance',widget:'flowseries'}));
            };
            function getInstanceURL(obj) {
                var vmIntfObj = $('#dropdownIP').data('kendoDropDownList').dataItem();
                return constructReqURL($.extend({},obj,{ip:vmIntfObj['ip_address'],vnName:vmIntfObj['virtual_network'],vmName:obj['fqName'],vmVnName:vmIntfObj['vm_vn_name']}));
            }
            data['charts']['colCount'] = 3;
            data['charts']['id'] = 'instance';
            data['charts']['d'] = [{
                    title:'Top Ports' ,
                    link:{view:'list',type:'port',fqName:obj['fqName'],srcVN:obj['srcVN'],context:'instance'},
                    class:tenantNetworkMonitorView,
                    url:function() {
                        return getInstanceURL($.extend({},obj,{context:'instance',type:'port'}));
                    },
                    objectType:'port'
                },{
                    title:'Top Peers',
                    link:{view:'list',type:'peer',fqName:obj['fqName'],srcVN:obj['srcVN'],context:'instance'},
                    url: function() {
                        return getInstanceURL($.extend({},obj,{context:'instance',type:'peer'}));
                    },
                    objectType:'peer'
                },{
                    title :'Top Flows',
                    link :{view:'list',type:'flow',fqName:obj['fqName'],srcVN:obj['srcVN'],context:'instance'},
                    url: function() {
                        return getInstanceURL($.extend({},obj,{context:'instance',type:'flow'}));
                    },
                    objectType:'flow'
                }];
        } else if(objType == 'portdetail') {
            layoutHandler.setURLHashParams($.extend(obj,{view:'summary'}),{merge:false});
            template = 'port-detail-template';
            if(obj['context'] == 'instance') {
                obj['title'] = kendo.format('Traffic Statistics for Protocol {2} Port {0} {1}',obj['port'], getTitleFromContextObj(obj),formatProtocol(obj['protocol']));
                obj['gridTitle'] = kendo.format('Top Peers for Protocol {2} Port {0} {1}',obj['port'], getTitleFromContextObj(obj),formatProtocol(obj['protocol']));
            } else {
                obj['title'] = kendo.format('Traffic Statistics for Protocol {2} Port {0} ({1})',obj['port'], getTitleFromContextObj(obj),formatProtocol(obj['protocol']));
                obj['gridTitle'] = kendo.format('Top Peers for Protocol {2} Port {0} ({1})',obj['port'], getTitleFromContextObj(obj),formatProtocol(obj['protocol']));
            }
            data['ts-chart'] = {};
            data['ts-chart']['url'] = constructReqURL($.extend({},obj,{widget:'flowseries'}));
            data['grids'] = {
                url:constructReqURL($.extend({},obj,{type:'peer',view:'list'})),
                columns : peerColumns
            };
        } else if(objType == 'peerdetail') {
            template = 'port-detail-template';
            layoutHandler.setURLHashParams($.extend(obj,{view:'summary'}),{merge:false});
            obj['title'] = kendo.format('Traffic Statistics for {0} ({1})',obj['ip'], obj['vnName']);
            obj['gridTitle'] = kendo.format('Top Ports for {0} ({1})',obj['ip'], obj['vnName']);
            data['ts-chart'] = {};
            data['ts-chart']['url'] = constructReqURL($.extend({},obj,{context:'instance',widget:'flowseries'}));
            data['grids'] = {
                url:constructReqURL($.extend({},obj,{type:'port',context:'instance',view:'list'})),
                columns : portColumns
            };
        } else if(objType=='portRangeDetail'){
            if(obj['port'].indexOf('-') > -1)
                template='portRangeDetail-template';
            else
                template = 'portDetail-template';
            var lcolumns=[];
            var columns=[
                {
                    field:"sourceip",
                    title:"Source IP"
                },{
                    field:"destip",
                    title:"Destination IP"
                },{
                    field:"protocol",
                    title:"Protocol",
                    template:'#= getProtocolName(protocol) #'
                },{
                    field:"sport",
                    title:"Source Port"
                },{
                    field:"dport",
                    title:"Destination Port" 
                },{
                    field:"sum_bytes",
                    title:"Sum(Bytes)"   
                },{
                    field:"sum_packets",
                    title:"Sum(Packets)"
                }];
            if(obj['fqName'].split(':').length==2)
                lcolumns=[
                    {
                        field:'sourcevn',
                        title:'Source VN',
                        searchable:true
                    },{
                        field:'destvn',
                        title:'Destination VN',
                        searchable:true
                    }];
            else if(obj['fqName'].split(':').length==3 && obj['portType']=='src')
                lcolumns=[
                    {   field:'destvn',
                        title:'Destination VN',
                        searchable:true
                    }];
            else if(obj['fqName'].split(':').length==3 && obj['portType']=='dst')
                lcolumns=[
                    {
                        field:'destvn',
                        title:'Destination VN',
                        searchable:true
                    }];
            data['grids']={
                url:function() {
                    var protocol='TCP';
                    if($('.toggleProtocol.selected').length > 0) {
                        //protocol = $('.toggleProtocol.selected').text();
                        protocol = $.map($('.toggleProtocol.selected'),function(obj,idx) {
                            return $(obj).text().toLowerCase();
                        });
                    }
                    return constructReqURL($.extend({},obj,{protocol:protocol}));
                },
                config:{
                    widgetGridTitle:'Flows',
                    widgetGridActions: ['<a class="toggleProtocol selected">ICMP</a>','<a class="toggleProtocol selected">UDP</a>','<a class="toggleProtocol selected">TCP</a>'],
                    noMsg:'No Flows for the given criteria'
                },
                columns:lcolumns.concat(columns),
                parseFn:function(response){
                    //objSummaryView['gridData'] = response['data'];
                    //self.gridData = response['data'];
                    $.each(response['data'],function(idx,currObj) {
                        currObj['sport'] = getIANAServiceForPort(currObj['protocol'],currObj['sport']);
                        currObj['dport'] = getIANAServiceForPort(currObj['protocol'],currObj['dport']);
                        currObj['sum_bytes'] = formatBytes(currObj['sum_bytes']);
                    });
                    return response.data;
                }
            };
        }
        var summaryTemplate = kendo.template($('#' + template).html());
        $(pageContainer).html(summaryTemplate(obj));
        //$('#main-container').find('.summary-view');
        var contentElem = $(pageContainer);

        var contextObj = getContextObj(obj);
        $.extend(data,contextObj);
        //Load the data for the components not handled by initTemplates
        //Also, feed the data if same dataSource URL is used for multiple components
        if(obj['type'] == 'instance') {
            function onInstanceIntfChange(e,refresh) {
                var refresh = ifNull(refresh,true);
                var ip = getSelInstanceFromDropDown()['ip'];
                var network = getSelInstanceFromDropDown()['vnName'];
                instViewModel.set('network',network);
                $('.example-title.main').html(function(idx,oldHtml) {
                    var str = $.trim(oldHtml);
                    return str.replace(/(.* -) ([^ ]*) (\(.*\))/,'$1 ' + ip + ' $3');
                });
                if(refresh == true) {
                    monitorRefresh();
                }
            }
            var instDeferredObj = $.Deferred();
            var dropdownIP = contentElem.find('.z-dropdown').kendoDropDownList({
                    //template:'#= data.ip_address # (#= data.virtual_network#)',
                    dataTextField:'name',
                    dataSource: {
                        transport: {
                            read: {
                                url:'/api/tenant/networking/vm/ip-list?vmName=' + obj['fqName']
                            }
                        },
                        schema: {
                            parse:function(response) {
                                if(response['ipList'].length > 0) {
                                    setTimeout(function() {
                                        $(pageContainer).initTemplates(data);
                                        onInstanceIntfChange(null,false);
                                        instDeferredObj.resolve();
                                        },200);
                                } else {
                                    $('.ts-chart').html("<div class='no-data'><div class='no-data-text'>Error in fetching Instance IP List</div></div>");
                                    $('.z-dropdown').hide();
                                    $('.flow-series.sub-title').hide();
                                }
                                response['ipList'] = $.map(response['ipList'],function(obj,idx) {
                                    obj['name'] = kendo.format('{0} ({1})',obj['ip_address'],obj['virtual_network']);
                                    return obj;
                                });
                                response['fipList'] = $.map(response['fipList'],function(obj,idx) {
                                    obj['name'] = kendo.format('{0} ({1})',obj['ip_address'],obj['virtual_network']);
                                    return obj;
                                });
                                return response['ipList'].concat(response['fipList']);
                            }
                        },
                        requestEnd: function(e) {
                        }
                    },
                    change:onInstanceIntfChange
                }).data('kendoDropDownList');
        }

        if(obj['type'] == 'network') {
            var instanceTabLoaded = 0;
            $('#network-tabs').kendoTabStrip({
                activate: function(e) {    
                    var selTab = $(e.item).text();
                    if(selTab == 'Port Distribution')
                        $(window).resize();
                    else if(selTab == 'Instances') {
                        if(instanceTabLoaded == 0) {
                            $('#networkInstances .k-grid').data('kendoGrid').dataSource.read();
                            instanceTabLoaded = 1;
                        }
                    }
                    $('.qtip').remove();
                    var topo_divId=obj['fqName'].replace(/-/g,'_').replace(/:/g,'_');
            	    if($('#network-tabs').find('div.k-state-active').find('#topology').length>0 && 
            	    		$("#"+topo_divId).data('topology')!=undefined){
            	              $("#"+topo_divId).html('');
            	    	      renderTopology($("#"+topo_divId).data('topology'));
                          }
                    },
                }).data('kendoTabStrip').select(0);
                //data['charts'] = {};
                data['charts']['chartType'] = 'bubble';
                var portDeferredObj = $.Deferred();
                $.ajax({
                    url: constructReqURL($.extend({},obj,{type:'port'}))
                }).done(function(result) {
                    portDeferredObj.resolve(result);
                });
                var uveDeferredObj = $.Deferred();
                $.ajax({
                    url:'/api/tenant/networking/virtual-network/summary?fqNameRegExp=' + obj['fqName'] 
                }).done(function(result) {
                    $("#uve-information").text(JSON.stringify(result, null, 1));
                    uveDeferredObj.resolve(result);
                });
                data['charts']['colCount'] = 1;
                data['charts']['d'] = [
                    {deferredObj:portDeferredObj,title:'Port Distribution',parseFn:function(response) {
                        var retObj = {d:[{key:'Source Port',values:parsePortDistribution(response['sport'],{bandwidthField:'outBytes',flowCntField:'outFlowCount',portField:'sport'})},
                                   {key:'Destination Port',values:parsePortDistribution(response['dport'],{bandwidthField:'inBytes',flowCntField:'inFlowCount',portField:'dport'})}],
                            forceX:[0,1000],xLblFormat:d3.format(''),yDataType:'bytes',fqName:obj['fqName'],
                            yLbl:'Bandwidth',link:{hashParams:{q:{view:'list',type:'project',fqName:obj['fqName'],context:'domain'}}},
                            tooltipFn:tenantNetworkMonitor.portTooltipFn,title:'Port Distribution',xLbl:'Port'
                            }
                        return retObj;
                        }
                     }];
                $(pageContainer).initTemplates(data);
                //Init Port Distribution map charts
                initDeferred({deferredObj:uveDeferredObj,renderFn:'initHeatMap',selector:$('#srcUdpPortMap'),parseFn:function(response) {
                        return parsePortMap(jsonPath(response,'$..udp_sport_bitmap')[0]);
                    }
                });
                initDeferred({deferredObj:uveDeferredObj,renderFn:'initHeatMap',selector:$('#dstUdpPortMap'),parseFn:function(response) {
                        return parsePortMap(jsonPath(response,'$..udp_dport_bitmap')[0]);
                    }
                });
                initDeferred({deferredObj:uveDeferredObj,renderFn:'initHeatMap',selector:$('#srcTcpPortMap'),parseFn:function(response) {
                        return parsePortMap(jsonPath(response,'$..tcp_sport_bitmap')[0]);
                    }
                });
                initDeferred({deferredObj:uveDeferredObj,renderFn:'initHeatMap',selector:$('#dstTcpPortMap'),parseFn:function(response) {
                        return parsePortMap(jsonPath(response,'$..tcp_dport_bitmap')[0]);
                    }
                });
                objListView.load({view:'list',type:'instance',fqName:obj['fqName'],context:'network',selector:'#networkInstances'});
        } else if(obj['type'] == 'domain') {
            domainDeferredObj.fail(function() {
                $('.stack-chart').html(timeoutTemplate({}));
            });
            //domainDeferredObj.done(function(d) {
                data['charts']['chartType'] = 'bubble';
                data['charts']['d'] = [
                    {deferredObj:domainDeferredObj,title:'Projects',parseFn:function(response) {
                        return {
                            d:[{key:'Control Nodes',values:response['projectsData']}],xLbl:'Interfaces',yLbl:'Networks',forceX:[0,5],forceY:[0,10],
                            link:{hashParams:{q:{view:'list',type:'project',fqName:obj['fqName'],context:'domain',source:'uve'}},
                            conf:{p:'mon_net_projects',merge:false}},
                            tooltipFn:tenantNetworkMonitor.projectTooltipFn
                        }}},
                    {deferredObj:domainDeferredObj,title:'Networks',forceX:[0,5],forceY:[0,10],parseFn:function(response) {
                        return {
                            d:[{key:'Analytics Nodes',values:response['networksData']}],xLbl:'Interfaces',yLbl:'Connected Networks',forceX:[0,5],forceY:[0,10],
                            link:{hashParams:{q:{view:'list',type:'network',fqName:obj['fqName'],source:'uve',context:'domain'}},
                            conf:{p:'mon_net_networks',merge:false}},
                            tooltipFn:tenantNetworkMonitor.networkTooltipFn
                            }}}];
            //});
            $(pageContainer).initTemplates(data);
        } else if(obj['type'] == 'project') {
                var instanceTabLoaded = 0;
                $('#project-tabs').kendoTabStrip({
                	activate: function(e) {    
                	    $('.qtip').remove();
                		var topo_divId=obj['fqName'].replace(/-/g,'_').replace(/:/g,'_');
                        if($('#project-tabs').find('div.k-state-active').find('#topology').length>0
                                && $("#"+topo_divId).data('topology')!=undefined){
                        	$("#"+topo_divId).html('');
                        	renderTopology($("#"+topo_divId).data('topology'));
                        }
                        var selTab = $(e.item).text();
                        if(selTab == 'Summary')
                            $(window).resize();
                        else if(selTab == 'Instances') {
                            //Issue the request only for the first time when Instances tab is selected
                            if(instanceTabLoaded == 0) {
                                $('.k-grid').data('kendoGrid').dataSource.read();
                                instancesTabLoaded = 1;
                            }
                        }
                    }
                }).data('kendoTabStrip').select(0);
                var deferredObj = $.Deferred();
                $.ajax({
                    url:constructReqURL($.extend({},obj,{type:'port'}))
                }).done(function(result) {
                    deferredObj.resolve(result);
                });
                data['charts']['chartType'] = 'bubble';
                data['charts']['colCount'] = 1;
                data['charts']['d'] = [
                    {deferredObj:deferredObj,title:'Port Distribution',parseFn:function(response) {
                        var retObj = {d:[{key:'Source Port',values:parsePortDistribution(response['sport'],{bandwidthField:'outBytes',flowCntField:'outFlowCount',portField:'sport'})},
                                   {key:'Destination Port',values:parsePortDistribution(response['dport'],{bandwidthField:'inBytes',flowCntField:'inFlowCount',portField:'dport'})}],
                            forceX:[0,1000],xLblFormat:d3.format(''),yDataType:'bytes',fqName:obj['fqName'],
                            yLbl:'Bandwidth',link:{hashParams:{q:{view:'list',type:'project',fqName:obj['fqName'],context:'domain'}}},
                            tooltipFn:tenantNetworkMonitor.portTooltipFn,title:'Port Distribution',xLbl:'Port'
                            }
                        return retObj;
                        }
                    }];
                $(pageContainer).initTemplates(data);
                objListView.load({view:'list',type:'instance',fqName:obj['fqName'],context:'project',selector:'#projInstances'});
        } else if(obj['type'] == 'instance') {
                $.ajax({
                    url:'/api/tenant/networking/virtual-machine/summary?fqNameRegExp=' + obj['fqName'] + '*'
                }).done(function(result) {
                    $("#uve-information").text(JSON.stringify(result, null, 1));
                    instDeferredObj.done(function(response) {
                        var statData = [{ lbl : 'Network',field:'network'},
                                        { lbl : 'vRouter',field:'vRouter'}];
                        var vRouter = ifNull(jsonPath(result,'$..vrouter')[0],'--');
                        instViewModel.set('vRouter',vRouter);
                        instViewModel.set('network',obj['srcVN']);
                        var dataSource = $('.summary-stats').data('dataSource');
                        var dashboardTemplate = kendo.template($('#dashboard-template').html());
                        $('#inst-stats').html(dashboardTemplate({noTitle:true,colCount:2,d:statData}));
                    });
                });
                $('#instance-tabs').kendoTabStrip({
                }).data('kendoTabStrip').select(0);
        } else if(obj['type'] == 'portRangeDetail') {
            var portTitle = (obj['portType'] == 'src') ? 'Source Port' : 'Destination Port'
            var portRange = [];
            var startPort,endPort;
            if(obj['port'].indexOf('-') > -1) {
                portRange = obj['port'].split("-") 
                startPort = parseInt(portRange[0]);
                endPort= parseInt(portRange[1]);
                pushBreadcrumb([obj['fqName'],portTitle + 's (' + obj['port'] + ')']);
            } else {
                portRange = [obj['port'],obj['port']];
                pushBreadcrumb([obj['fqName'],portTitle + ' ' + obj['port']]);
            }

            //Initialize bubble chart only if portRange is provided
            if(obj['port'].indexOf('-') > -1) {
                //Issue port distribution query.
                var portDeferredObj = $.Deferred();
                $.ajax({
                    url: constructReqURL($.extend({},obj,{type:'port'}))
                }).done(function(result) {
                    portDeferredObj.resolve(result);
                });
                data['charts']['chartType'] = 'bubble';
                data['charts']['colCount'] = 1;
                data['charts']['d'] = [
                    {deferredObj:portDeferredObj,title:'Port Distribution',parseFn:function(response) {
                        var portData,valueField,flowCntField;
                        if(obj['portType'] == 'src') {
                            portData = response['sport'];
                        } else {
                            portData = response['dport'];
                        }
                        var portType = obj['portType'] == 'dst' ? 'dport' : 'sport';
                        flowCntField = obj['portType'] == 'dst' ? 'inFlowCount' : 'outFlowCount';
                        portData = $.map(portData,function(currObj,idx) {
                            if(currObj[portType] >= portRange[0] && currObj[portType] <= parseInt(portRange[1]))
                                return currObj;
                            else
                                return null;
                        });
                        if(obj['portType'] == 'src')
                            portData = parsePortDistribution(portData,{bandwidthField:'outBytes',flowCntField:'outFlowCount',portField:'sport',startPort:startPort,endPort:endPort});
                        else
                            portData = parsePortDistribution(portData,{bandwidthField:'inBytes',flowCntField:'inFlowCount',portField:'dport',startPort:startPort,endPort:endPort});

                        var retObj = {d:[{key:'Source Port',values:portData}],
                            forceX:[startPort,endPort],xLblFormat:d3.format(''),yDataType:'bytes',fqName:obj['fqName'],
                            yLbl:'Bandwidth',link:{hashParams:{q:{view:'list',type:'project',fqName:obj['fqName'],context:'domain'}}},
                            tooltipFn:tenantNetworkMonitor.portTooltipFn,title:'Port Distribution',xLbl:'Port'
                            }
                        return retObj;
                        }
                    }];
            }
            /* Start - Port Histogram
            portDeferredObj.done(function(response) {
                var portCF = crossfilter(portData);
                var portDim = portCF.dimension(function(d) { return d[portType]});
                var allPortData = [];
                var maxValue = d3.max(portData, function (d) {
                    return d[flowCntField];
                });
                var zeroValue = maxValue/20;
                zeroValue = 0;
                for(var i=startPort;i<=endPort;i++) {
                    if(portDim.filter(i).top(Infinity).length == 1)
                        allPortData.push(portDim.filter(i).top(1)[0]);
                    else {
                        if(obj['portType'] == 'dst')
                            allPortData.push({
                                dport : i,
                                inFlowCount :zeroValue 
                            });
                        else
                            allPortData.push({
                                sport : i,
                                outFlowCnt : zeroValue
                            });
                    }
                }
                $('.sparkline').initSparkLineChart({dataSource:{data:allPortData},valueField:flowCntField,
                    tooltipTemplate: 'Port #= dataItem.' + portType + '# : ' + '#= dataItem.' + flowCntField + '#'});
            });
             End - Port Histogram */
            $(pageContainer).initTemplates(data);
            $('.toggleProtocol').on('click',function() {
                $(this).toggleClass('selected');
                //If no protocol is selected,select all
                if($('.toggleProtocol.selected').length == 0) {
                    $('.toggleProtocol').addClass('selected');        
                }
                showGridLoading($('.k-grid').data('kendoGrid'));
                reloadKendoGrid($('.k-grid').data('kendoGrid'));
            });
            //Initialize crossfilter chart once grid is initialized
            /*$('.k-grid').data('kendoGrid').bind('dataBound',function(gridData) {
                var gridData = $('.k-grid').data('kendoGrid').dataSource.data();
                //gridData = self.gridData;
                function plotPortCrossFilter(gridData) {
                    var flowCF = crossfilter(gridData);
                    var flowDim = flowCF.dimension(function(d) { return d[portType == 'sport' ? 'dport' : 'sport']});
                    var filterDim = flowCF.dimension(function(d) { return d[portType == 'sport' ? 'dport' : 'sport']});
                    charts = [
                        barChart()
                            .dimension(flowDim)
                            .group(flowDim.group())
                            .toolTip(true)
                          .x(d3.scale.linear()
                            .domain([0, 68000])
                            .rangeRound([0, 10 * 100])), //Width
                        ];
                  chart = d3.selectAll(".chart")
                      .data(charts)
                      .each(function(currChart) { currChart.on("brush", function() {
                          logMessage('networkMonitor',filterDim.top(10));
                          updateView();
                          //renderAll(chart);
                      }).on("brushend", function() { 
                          //updateView();
                          //renderAll(chart);
                      }); 
                    });
                    renderAll(chart);
                    function updateView() {
                        $('.k-grid').data('kendoGrid').dataSource.data(filterDim.top(Infinity));
                    }
                  $('.reset').on('click',function() {
                      //var idx = $(this).closest('.chart').index();
                      //charts[idx].filter(null);
                      //renderAll(chart);
                      //updateView();
                  });
                }
            });*/
        } else
            $(pageContainer).initTemplates(data);   //We are not passing the contextObj to initTemplates as context is already encoded in URL
    }
}
var objSummaryView = new ObjectSummaryView();

function tenantNetworkMonitorClass() {
    var self = this;
    this.timeObj = {};
    var treeView = null,currView = null;
    
    //Pass on the window resize event to the respective view
    this.onWindowResize = function() {
        return;
    }

    this.destroy = function() {
        //To unload dynamically loaded javascript,ensure that you define it inside a closure 
        //so that there will be only one handle to that closure execution context and can be
        //removed easily.
        delete contView;
        delete contentView;
        //Revert back ajax defaultTimeout
        $.ajaxSetup({
            timeout:30000
        });
    }

    this.updateViewByHash = function(hashObj,lastHashObj) {
        var dataItem;
        //If there is any hash string present in the URL,select that node accordingly
        if((hashObj != null) && (hashObj != '') && typeof(hashObj) == 'object') {
            if(currView != null)
                currView.destroy();
            if((hashObj['fqName'] != null) && hashObj['view'] == null) {
                var fqNameLen = hashObj['fqName'].split(':').length;
                if(hashObj['srcVN'] != null)  { //Connected Network
                    dataItem = selTreeNode({fqName:hashObj['srcVN']+':Connected Networks:' + hashObj['fqName'].split(':').pop(),expand:true,selectFirst:true,trigger:false}); 
                    if(dataItem != false) {
                        if(hashObj['fqName'].match(/\w{8}-\w{4}-\w{4}-\w{4}-\w{12}/)) {
                            objSummaryView.load({type:'instance',vmName:hashObj['vmName'],fqName:hashObj['fqName'],srcVN:hashObj['srcVN']}); 
                        } else
                            objSummaryView.load({context:'connected-nw',type:'connected-nw',fqName:hashObj['fqName'],srcVN:hashObj['srcVN']}); 
                    }
                } else {
                    dataItem = selTreeNode({fqName:hashObj['fqName'],expand:true,selectFirst:true,trigger:false}); 
                    //undefined != false [true]
                    if(dataItem != false) {
                        if(fqNameLen == 1) {     //Domain
                            objSummaryView.load({context:'domain',type:'domain',fqName:hashObj['fqName']}); 
                        } else if(fqNameLen == 2) {    //Project
                            if(hashObj['portType']!=null && hashObj['port']!=null){
                                objSummaryView.load({context:'project',type:'portRangeDetail',
                                    fqName:hashObj['fqName'],port:hashObj['port'],protocol:hashObj['protocol'],portType:hashObj['portType']})}
                            else
                            objSummaryView.load({context:'project',type:'project',fqName:hashObj['fqName']}); 
                        } else if(fqNameLen == 3) { //Network
                            if(hashObj['portType']!=null && hashObj['port']!=null) {
                                objSummaryView.load({context:'network',type:'portRangeDetail',
                                    fqName:hashObj['fqName'],port:hashObj['port'],protocol:hashObj['protocol'],portType:hashObj['portType']})}
                            else
                            objSummaryView.load({context:'network',type:'network',fqName:hashObj['fqName']}); 
                        } else if(fqNameLen > 2) {   //Instance
                            var matchArr = hashObj['fqName'].match(/(.*):Instances:(.*)/);
                            objSummaryView.load({type:'instance',fqName:matchArr[2],srcVN:matchArr[1]}); 
                        }
                    } else {
                        //Select default page
                    }
                }
            } else if(hashObj['view'] != null) {
                if(hashObj['fqName'] != null) {
                    selTreeNode({fqName:hashObj['fqName'],expand:true,selectFirst:true,trigger:false}); 
                } else {
                    //Select default view
                    selTreeNode({expand:true,selectFirst:true,trigger:false}); 
                }
                subViews[hashObj['view']].load(hashObj);
            } else {
                selTreeNode({expand:true,selectFirst:true,trigger:false}); 
            }
        } else {
            selTreeNode({expand:true,selectFirst:true,trigger:false}); 
        }
    }

    this.load = function() {
        //Change ajax defaultTimeout for this screen
        $.ajaxSetup({
            timeout:60000
        });
        var monitorTemplate = kendo.template($("#monitor-template").html());
        $(contentContainer).html('');
        $(contentContainer).html(monitorTemplate);
        self.updateViewByHash(layoutHandler.getURLHashParams());
        initializeRefreshBtn();
    }

    var subViews = {list:objListView,summary:objSummaryView};
    this.loadSubView = function(obj) {
        if(obj['view'] != "") {
            subViews[obj['view']].load(obj); 
            //subViews[obj['view']].load({fqName:'default-domain',type:'network'}); 
        }
    }
}
var tenantNetworkMonitorView = new tenantNetworkMonitorClass();

//Center Region
function contentView() {
    this.destroy = function() {
        $(pageContainer).html('');
    }
}

contView = new contentView();

//@@ sourceURL=tenant_monitor_network.js

function getSelInstanceFromDropDown() {
    if($('#dropdownIP').length == 0)
        return {};
    var vmIntfObj = $('#dropdownIP').data('kendoDropDownList').dataItem();
    return {ip:vmIntfObj['ip_address'],vnName:vmIntfObj['virtual_network']};
}

function getTitleFromContextObj(ctxObj) {
    if(ctxObj['fqName'] != null)  {
        if(ctxObj['srcVN'] == null) {   //Project/Network/Domain
            return ctxObj['fqName'];
        } else if(ctxObj['ip'] != null) {   //Instance
            return ', ' + ctxObj['ip'] + ' (' + ifNull(ctxObj['vnName'],ctxObj['srcVN']) + ')';
        } else if(ctxObj['srcVN'] != null) {    //Connected-network
            if(ctxObj['fqName'] == ctxObj['srcVN'])
                return 'with in ' + stripOffProject(ctxObj['fqName']);
            else
                return stripOffProject(ctxObj['fqName']) + ' -> ' + stripOffProject(ctxObj['srcVN']);
        } 
    }
}

function getConnectedTitleFromContextObj(ctxObj) {
    if(ctxObj['srcVN'] == ctxObj['fqName']) {
        return kendo.format("with in virtual network {0}",stripOffProject(ctxObj['srcVN']));
    } else
        return kendo.format("between virtual network {0} and {1}",stripOffProject(ctxObj['srcVN']),stripOffProject(ctxObj['fqName']));
}

function initializeRefreshBtn() {
    $(pageContainer).siblings().filter('.refresh-btn').on('click',function() {
        monitorRefresh($(pageContainer));
    });
}

function autoRefresh() {
    //Once the view is loaded,call autoRefresh and cancel on switching to a different view
    //Start the timer only after all the ajax calls are done..Need to poll for this
    //Some-times only one ajax call is issued if datasource is shared,but good thing that parseFn is called twice
}

function areAllCompsLoaded(selector) {
    var classes = ['.summary-stats','.stack-chart','.z-grid','.ts-chart'];
    var elems = [],loadedElems=[];
    $.each(classes,function(idx,value) {
        if(elems.length == 0)
            elems = $(selector).find(value);
        else
            elems = elems.add($(selector).find(value));
    });
    elems = flattenList(elems);
    var loadedElems = $.map(elems,function(obj,idx) {
        if($(obj).data('loaded') == true)
            return true;
        else
            return null;
    });
    if(elems.length == loadedElems.length)
        return true;
    return false;
}

function drawTopology(fqName) {
	var url,type,name,cyto_layout='grid';
	//var framework="cytoscape",cyto_layout='grid';//[cytoscape,d3],//[breadthfirst,grid]
	var framework="d3";//[cytoscape,d3]
	url='/api/tenant/monitoring/network-topology?fqName='+fqName;
	if(fqName.split(':').length==2){
		type='project';
		name=fqName.split(':').pop();
	}if(fqName.split(':').length==3){
		type='network';
	}
	var divId=fqName.replace(/:/g,'_');
	divId=divId.replace(/-/g,'_');
	$.getJSON(url,function(response){
		if(response!=null){
			var result=filterResponse(response.nodes,response.links);
			response.nodes=result.nodes;
			response.links=result.links;
			response.framework=framework;
			response.cyto_layout=cyto_layout;
			response.fqName=fqName;
			response.divId=divId;
			/*Hide the connectivity details if there are no links
				if(type=='network' && response.links.length==0){
				$("#networkSummaryTab").hide();
				return;}
			$("#networkSummaryTab").show();*/
			if($("#topology").find('#'+divId).length==0)
				$("#topology").append("<div id=\""+divId+"\"></div>");
			$("#"+divId).data('topology',response);
			$("#"+divId).data('fqName',fqName);
			renderTopology(response);
		}else{
			$("#topology").addClass('text-center');
			$("#topology").html("An unexpected error occured.<br/>Please try reloading the page");
		}
	})
}

function renderTopology(response){
	var divId=response.divId;
	var fqName=response.fqName,domain,project;
	domain=fqName.split(':')[0];
	project=fqName.split(':')[1];
	if(response.nodes==undefined || response.nodes.length==0){
		$("#topology").addClass('topo_center');
		$("#topology").html("No Networks found !!!!!");
		return;
	}
	if(response.framework=='d3'){
		var network_topology=new topology();
		//var width=600;
		var height_div=650;
		var nodes=response.nodes;
		var bw_rng={};
		var data={};
		var size=350;
		var height_div;
		var links=response.links;
		if(nodes.length>0 && nodes.length<5){
    		size=500;height_div=160;}
    	else if(nodes.length>=5 && nodes.length<10){
    		size=450;height_div=230;}
    	else if(nodes.length>=10 && nodes.length<20){
    		size=400;height_div=330;}
    	else if(nodes.length>=20 && nodes.length<30){
    		height_div=400}
    	else if(nodes.length>=30 && nodes.length<40){
    		height_div=470;}
    	else if(nodes.length>=40 && nodes.length<50){
    		height_div=580;}
		    for(var i=0;i<nodes.length;i++){
		    	var configData={};
		    	var dmn=nodes[i].name.split(':')[0],prj=nodes[i].name.split(':')[1];
		    	configData.id=nodes[i].name;
		    	configData.name=nodes[i].name.split(':').pop();
		    	configData.type=nodes[i].node_type;
		    	configData.selected=false;
		    	configData.shape='circle';
		    	configData.vm_count=0;
		    	configData.fip_count=0;
		    	configData.in_bytes=0;
		    	configData.in_tpkts=0;
		    	configData.out_tpkts=0;
		    	configData.out_bytes=0;
		    	if(nodes[i].node_type=='virtual-network' && nodes[i].more_attr!=undefined){
		    		configData.vm_count=nodes[i].more_attr.vm_cnt;
					configData.fip_count=nodes[i].more_attr.fip_cnt;
					configData.in_bytes=formatBytes(nodes[i].more_attr.in_bytes);
					configData.out_bytes=formatBytes(nodes[i].more_attr.out_bytes);
					configData.out_tpkts=nodes[i].more_attr.out_tpkts;
					configData.in_tpkts=nodes[i].more_attr.in_tpkts;}
				if(nodes[i].node_type=='service-instance'){
					var siData=ifNull(jsonPath(response,'$..service-instances')[0],[]);
					for(var j=0;j<siData.length;j++){
						if(siData[j]['service-instance']['fq_name'].join(':')==nodes[i]['name'])
							configData.vm_count=ifNull(siData[j]['service-instance']['virtual_machine_back_refs'].length,0);
					}
					//var ser_insts=configData.
					configData.shape='square';}
				if( nodes[i].name==fqName)
					configData.selected=true;
				configData.size=size;
				if(domain==dmn && project==prj)
				    configData.display_name=nodes[i].name.split(':')[2];
				else if(domain==dmn && project!=prj)
					configData.display_name=nodes[i].name.split(':')[1]+":"+nodes[i].name.split(':')[2];
				else if(domain!=dmn && project!=prj)
					configData.display_name=nodes[i].name.split(':')[0]+":"+nodes[i].name.split(':')[1]+":"+nodes[i].name.split(':')[2];
				network_topology.addNode_d3(configData);
		    }
		    for(var j=0;j<links.length;j++){
		    	bw_rng=getBandwidthRange(response);
		    	if(links[j].service_inst!=undefined){   //Creating links for connecting service instances
		    		var sv_links=[];
		    		var sv_inst=links[j].service_inst;
		    		var firstLink={},secondLink={};
	    			firstLink.src=links[j].src;
		    		firstLink.dst=sv_inst[0];
		    		firstLink.dir=links[j].dir;
		    		firstLink.org_dest=links[j].dst;
		    		firstLink.org_src=links[j].src;
		    		firstLink.more_attributes=links[j].more_attributes;
			    	var result=constructLinkData(links[j],links.length,bw_rng);
			    	firstLink.loss=result.loss;			    	
			    	firstLink.packets=result.packets;
			    	firstLink.bytes=result.bytes;
			    	firstLink.toolTip=result.toolTip;
			    	firstLink.line_color=result.line_color;
			    	firstLink.width=result.width;
			    	if(result.error!=undefined){
			    		firstLink.error=result.error;
			    		firstLink.partialConnected=true;}
			    	if(result.toolTip_title!=undefined)
			    		firstLink.toolTip_title=result.toolTip_title;
			    	network_topology.addLink_d3(firstLink);
		    		if(sv_inst.length==1){
				    	secondLink.src=sv_inst[0];
			    		secondLink.dst=links[j].dst;
			    		secondLink.dir=links[j].dir;
			    		secondLink.org_dest=links[j].dst;
			    		secondLink.org_src=links[j].src;
			    		secondLink.more_attributes=links[j].more_attributes;
			    		secondLink.loss=result.loss;				   
				    	secondLink.packets=result.packets;
				    	secondLink.bytes=result.bytes;
				    	secondLink.toolTip=result.toolTip;
				    	secondLink.line_color=result.line_color;
				    	secondLink.width=result.width;
				    	if(result.error!=undefined){
				    		secondLink.error=result.error;
				    		secondLink.partialConnected=true;}
				    	if(result.toolTip_title!=undefined)
				    		secondLink.toolTip_title=result.toolTip_title;
				    	network_topology.addLink_d3(secondLink);
		    		}else {
		    		for(var i=0;i<sv_inst.length;i++){      
		    			var link={};
		    			link.src=sv_inst[i];
		    			if(sv_inst[i+1]==undefined)
		    			    link.dst=links[j].dst;
		    			else
		    				link.dst=sv_inst[i+1];
		    			link.dir=links[j].dir;
		    			link.more_attributes=links[j].more_attributes;
		    			var result=constructLinkData(links[j],links.length,bw_rng);
		    			link.loss=result.loss;
		    			link.packets=result.packets;
		    			link.org_dest=links[j].dst;
		    			link.org_src=links[j].src;
		    			link.bytes=result.bytes;
		    			link.toolTip=result.toolTip;
		    			link.line_color=result.line_color;
		    			link.width=result.width;
				    	if(result.error!=undefined){
				    		link.error=result.error;
				    		configData.partialConnected=true;}
				    	if(result.toolTip_title!=undefined)
				    		link.toolTip_title=result.toolTip_title;
		    			network_topology.addLink_d3(link);}
		    		}
		    	}else{
		    		var configData={};
			    	configData.src=links[j].src;
			    	configData.dst=links[j].dst;
			    	configData.dir=links[j].dir;
			    	configData.org_dest=links[j].dst;
			    	configData.org_src=links[j].src;
			    	configData.more_attributes=links[j].more_attributes;
			    	var result=constructLinkData(links[j],links.length,bw_rng);
			    	configData.loss=result.loss;
			    	configData.packets=result.packets;
			    	configData.bytes=result.bytes;
			    	configData.toolTip=result.toolTip;
			    	configData.line_color=result.line_color;
			    	configData.width=result.width;
			    	if(result.error!=undefined){
			    	   configData.error=result.error;
			    	   configData.partialConnected=true;}
			    	if(result.toolTip_title!=undefined)
			    	   configData.toolTip_title=result.toolTip_title;
		    	network_topology.addLink_d3(configData);}
		    }	
		    $("#"+divId).data('topology',response);
		    $("#"+divId).data('fqName',fqName);
		    $("#topology").css('width','100%');
			$("#topology").css('height',height_div);
			$("#"+divId).css('width','100%');
			$("#"+divId).css('height',height_div);
		    network_topology.loadD3(divId);
	}
	else if(response.framework=="cytoscape" && response.cyto_layout=="breadthfirst"){
		var layout='breadthfirst';
		var width=600;
		var weight=30;
		var height=75;
		var height_div=300;
		var dstNodes=new Array();
		//If number of nodes is <2 we are using the grid layout because of issues with breadthfirst
		if(response.nodes.length<=2){
			layout='grid';height_div=90;width=400;weight=40;height=135
		}else if(response.nodes.length>2 && response.nodes.length<5){
			height_div=200;width:600;
		}else if(response.nodes.length>=5 && response.nodes.length<=10){
		    width=700;
		}else if(response.nodes.length>10 && response.nodes.length<=20){
			width=800;
		}else if(response.nodes.length>20 && response.nodes.length<=30){
			width=900;
		}else if(response.nodes.length>30){
			width=1100;
		}
		//If there are no links breadth first layout is occupying more space so switching to grid layout
		if(response.links.length==0){
			layout='grid';weight=40;height=135;}
		response.weight=weight;
		response.height=height;
		response.divId=divId;
		response.layout=layout;
	    if(response.links!=undefined && response.links.length>0){
	    	for(var i=0;i<response.links.length;i++){
	    		dstNodes.push(response.links[i].dst);
	    	}	
	    }
	    $("#topology").css('width',width);
		$("#topology").css('height',height_div);
	    $("#"+divId).addClass('topology_'+layout);
	    response.dstNodes=dstNodes;
	    renderTopology_cytoscape(response);
	}
    else if(response.framework=="cytoscape" && response.cyto_layout=="grid"){
    	var layout='grid';
		var width=600;
		var weight=50;
		var height=135;
		var height_div=300;
		var left=300;
		var dstNodes=new Array();
		if(response.nodes.length>0 && response.nodes.length<5){
			height_div=90;
			width=400;
		}else if(response.nodes.length>=5 && response.nodes.length<=15){
		    height_div=200;	
		}else if(response.nodes.length>15 && response.nodes.length<=40){
			width=700;left=200;
			//node prop
			weight=40;height=115;
		}else if(response.nodes.length>40 && response.nodes.length<=60){
			width=800;left=150;
			//node prop
			weight=35;height=100;
		}else if(response.nodes.length>60){
			weight=30;height=85;
		}
		response.weight=weight;
		response.height=height;
		response.divId=divId;
		$("#topology").css('width',width);
		$("#topology").css('height',height_div);
		$("#"+divId).addClass('topology_'+layout);
	    renderTopology_cytoscape(response);
	}
}

function renderTopology_cytoscape(response){
	if(response.nodes.length>0){
		var network_topology=new topology();
		var weight=response.weight;
		var height=response.height;
		var nodes=response.nodes;
	    var edges=response.links;
	    var dstNodes=response.dstNodes;
	    var bw_rng={};
	    var data={};
	    for(i=0;i<nodes.length;i++){
			if(nodes[i].name!=undefined ){
			var configData={};
			var active=true;
			configData.id=nodes[i].name;
			configData.type=nodes[i].node_type;
			configData.name=nodes[i].name.split(':').pop();
			configData.dst=false;
			if(response.layout!='grid' && dstNodes!=undefined && dstNodes.indexOf(configData.id)!=-1)//In grid no need to handle the label alignment
				configData.dst=true;
			if(nodes[i].node_type=='virtual-network')
				configData.shape='circle';
			if(nodes[i].node_type=='service-instance')
				configData.shape='rectangle';
			configData.toolTip=nodes[i].name;
			configData.weight=weight;
			configData.height=height;
			if(nodes[i].status=='Deleted')
			    active=false;
			configData.active=active;
			network_topology.addNode(configData);}
	    }
	    for(i=0;i<edges.length;i++){
	    	bw_rng=getBandwidthRange(response);
			if(edges[i].src!=undefined && edges[i].dst!=undefined && edges[i].more_attributes!=undefined){
	    	var configData={};
			configData.id=edges[i].src+"_"+edges[i].dst;
			configData.src=edges[i].src;
			configData.dest=edges[i].dst;
			configData.source_arrow_color='#3182bd';
			configData.target_arrow_color='#3182bd';
			configData.line_color='#3182bd';//3182bd
			configData.name=edges[i].src+"_"+edges[i].dst;
			configData.strength=65;
			configData.width=1;
			if(edges[i].dir=='uni'){
				configData.target_arrow_shape='triangle';
				//configData.blink=true;
				configData.target_arrow_color='#E4564F';
				configData.line_color='#E4564F';
			}if(edges[i].dir=='bi'){
				configData.target_arrow_shape='triangle';
				configData.source_arrow_shape='triangle';
			}}
			if(edges[i].more_attributes!=undefined && edges[i].more_attributes.in_stats!=undefined && edges[i].more_attributes.out_stats!=undefined
					&& edges[i].more_attributes.in_stats.length>0 && edges[i].more_attributes.out_stats.length>0 ){
				data.src=edges[i].src;
				data.dst=edges[i].dst;
				data.more_attributes=edges[i].more_attributes;
				data.dir=edges[i].dir;
				var result=getLinkInfo(data);
				var toolTip;
				var toolTip_title="";
				if(edges[i].error!=undefined)
					toolTip_title="Error:"+edges[i].error;
				if(!result.status)
					toolTip_title="Error:Mismatch between in-stats and out-stats, difference is ";
				toolTip="Packets:"+result.pkts+" Bytes:"+formatBytes(result.bytes);
				configData.toolTip=toolTip;
				configData.title_tt=toolTip_title;
				if(!result.status || edges[i].error!=undefined){
					//configData.blink=true;
					if(edges[i].dir=='bi')
					    configData.target_arrow_color='#E4564F';
					configData.line_color='#E4564F';
					configData.source_arrow_color='#E4564F';
				}
				if(edges.length>1)
					configData.width=getLinkWidth(bw_rng.bytes[bw_rng.bytes.length-1],bw_rng.bytes[0],result.bytes);
				
			}else{
				var toolTip;
				var toolTip_title="";
				if(edges[i].error!=undefined){
					toolTip_title="Error:"+edges[i].error;
					configData.blink=true;
					if(edges[i].dir=='bi')
					   configData.target_arrow_color='#E4564F';
					configData.line_color='#E4564F';
					configData.source_arrow_color='#E4564F';}
				toolTip="Packets:0 Bytes:0";
				configData.width=1.25;
				configData.toolTip=toolTip;
				configData.title_tt=toolTip_title
			}network_topology.addEdge(configData);
	    }
	    network_topology.loadGraph(response.divId,response.layout);
	    }
}
function filterResponse(nodes,links){
	var result={};
	var nodes_act=[];
	var links_act=[];
    var ipFabricName =  'default-domain:default-project:ip-fabric';
	if(nodes!=undefined && links!=undefined){
	for(var i=0;i<nodes.length;i++){
		if(nodes[i].status=='Active' && (nodes[i]['name'] != ipFabricName))
			nodes_act.push(nodes[i]);
    }
	for(var i=0;i<links.length;i++){
		var src_act=false;
		var dst_act=false;
		var svc_exists=false;
		var svc_act=true;
        //Filter link if any of src/destination of the link is ip-fabric
        if(links[i]['src'] == ipFabricName || links[i]['dst'] == ipFabricName)
            continue;
		for(var j=0;j<nodes.length;j++){
			if(links[i].src==nodes[j].name && nodes[j].status=='Active')
				src_act=true;
			else if(links[i].dst==nodes[j].name && nodes[j].status=='Active')
				dst_act=true;
			else if(links[i]['service_inst']!=undefined && links[i]['service_inst'].length>0){
				svc_exists=true;
				for(var k=0;k<links[i]['service_inst'].length;k++){
					if(links[i]['service_inst'][k]==nodes[j].name && nodes[j].status=='Deleted')
						svc_act=false;
				}
			}
		}
		if(svc_exists){
		    if(src_act && dst_act && svc_act)
			   links_act.push(links[i]);}
		else if(src_act && dst_act)
			links_act.push(links[i]);
	}
   }
	result.nodes=nodes_act;
	result.links=links_act;
	return result;
}
function checkPacketLoss(data){
	var in_stats=data['more_attributes']['in_stats'];
	var out_stats=data['more_attributes']['out_stats'],loss_percent=0,in_pkt_diff=0,out_pkt_diff=0;
	var in_byte_diff=0,out_byte_diff=0,in_pkts=0,in_bytes=0,out_pkts=0,out_bytes=0,result={},diff=false;
	//To handle back end bug (getting one set of data in case bidirecitonal)  
	if(in_stats.length==1 && out_stats.length==1 && data.dir=='bi'){
		   if(data.src==in_stats[0].src){
			   var obj={};
			   obj['src']=data.dst,obj['dst']=data.src,obj['pkts']=0,obj['bytes']=0;
			   in_stats[1]=obj,out_stats[1]=obj;
		   }else if(data.dst==in_stats[0].src){
			   var obj={};
			   obj['src']=data.src,obj['dst']=data.dst,obj['pkts']=0,obj['bytes']=0;
			   in_stats[1]=obj,out_stats[1]=obj;
		   } 
		   //result.diff=true;
		   //result.loss_percent=100;
		   //return result;
	   }
	   for(var i=0;i<in_stats.length;i++){
			if(data.src==in_stats[i].src){
				for(var j=0;j<out_stats.length;j++){
					if(data.src==out_stats[j].dst && out_stats[j].pkts!=in_stats[i].pkts){
						diff=true;
						in_pkts=Math.max(out_stats[j].pkts,in_stats[i].pkts);
						in_bytes=Math.max(out_stats[j].bytes,in_stats[i].bytes);
						in_pkt_diff=Math.abs(in_stats[i].pkts-out_stats[j].pkts);
						in_byte_diff=Math.abs(in_stats[i].bytes-out_stats[j].bytes);}
				}
			}else if(data.dst==in_stats[i].src){
				for(var k=0;k<out_stats.length;k++){
					if(data.dst==out_stats[k].dst && out_stats[k].pkts!=in_stats[i].pkts){
						diff=true;
						out_pkts=Math.max(out_stats[k].pkts,in_stats[i].pkts);
						out_bytes=Math.max(out_stats[k].bytes,in_stats[i].bytes);
						out_pkt_diff=Math.abs(in_stats[i].pkts-out_stats[k].pkts);
						out_byte_diff=Math.abs(in_stats[i].bytes-out_stats[k].bytes);}
				}
			}
		}
	if(diff)
	loss_percent=((in_byte_diff+out_byte_diff))*(100/(in_bytes+out_bytes));
	result.diff=diff;
	result.loss_percent=loss_percent.toFixed(2);
	return result;
}
function constructLinkData(link,links_count,bw_rng){
	var configData={};
	configData.line_color="#3182bd";
	configData.partialConnected=false;
	if(link.more_attributes!=undefined && link.more_attributes.in_stats!=undefined && link.more_attributes.out_stats!=undefined
			&& link.more_attributes.in_stats.length>0 && link.more_attributes.out_stats.length>0 ){
	var loss=checkPacketLoss(link);
	var result=getLinkInfo(link);
	var toolTip;
	var toolTip_title="";
	if(link.error!=undefined){
		toolTip_title="Error:"+link.error;
		configData.partialConnected=true;
		configData.error=link.error;}
	if(!result.status){
		toolTip_title="Error:Mismatch between in-stats and out-stats and difference is ";
	configData.error="Mismatch between in-stats and out-stats and difference is ";}
	toolTip="Packets:"+result.pkts+" Bytes:"+formatBytes(result.bytes);
	configData.width=1.25;//default width value
	configData.packets=result.pkts;
	configData.bytes=formatBytes(result.bytes);
	configData.toolTip=toolTip;
	configData.title_tt=toolTip_title;
	configData.more_attributes=link.more_attributes;
	configData.dir=link.dir;
	configData.loss=loss;
	if( link.error!=undefined || loss.loss_percent>10 ){
		configData.line_color='#E4564F';}
	if(links_count>1 && (loss.loss_percent<10 || !loss.diff) && !configData.partialConnected)
		configData.width=getLinkWidth(bw_rng.bytes[0],bw_rng.bytes[bw_rng.bytes.length-1],result.bytes_new);
   }else{
	var toolTip;
	var toolTip_title="";
	if(link.error!=undefined){
		toolTip_title="Error:"+link.error;
		configData.partialConnected=true;
		configData.error=link.error;
		configData.line_color='#E4564F';}
	toolTip="Packets:0 Bytes:0";
	configData.width=1.25;
	configData.packets=0;
	configData.bytes=0;
	configData.toolTip=toolTip;
	configData.title_tt=toolTip_title;}
	return configData;
}
function getLinkInfo(data){
	if(data.more_attributes!=undefined && data.more_attributes.in_stats!=undefined && data.more_attributes.out_stats!=undefined){
	var in_stats=data.more_attributes.in_stats;
	var out_stats=data.more_attributes.out_stats;
	var result={};
	var pkts=0,bytes=0,status,msg,pkts_arr=[],bytes_arr=[];
	for(var i=0;i<in_stats.length;i++){
		if(in_stats[i].src==data.src)
			for(var j=0;j<out_stats.length;j++){
				var cdn;
				if(data.dir=='bi'){
					cdn="out_stats[j].dst==data.src";
				}else if(data.dir=='uni'){
					cdn="out_stats[j].src==data.src";
				}
				if(cdn){
					if((out_stats[j].pkts==in_stats[i].pkts && out_stats[j].bytes==in_stats[i].bytes) || getPacketLossPercentage(data))
						status=true;
					else
						status=false;
				}
			}
	}
	for(var i=0;i<in_stats.length;i++){
		if(in_stats[i].src==data.src)
			for(var j=0;j<out_stats.length;j++){
				if(status){
					if(out_stats[j].src==data.src){
						pkts=out_stats[j].pkts+in_stats[i].pkts;
						bytes=out_stats[j].bytes+in_stats[i].bytes;
					}
				}
				else{
					if(data.dir=='bi' && out_stats[j].src==data.src){
						//msg="<b>Source:</b>"+data.src.split(':').pop()+" <b>Target:</b>"+data.dst.split(':').pop()+"<br>";
						//msg="<b>In </b> Packets:"+in_stats[i].pkts+" Bytes:"+formatBytes(in_stats[i].bytes)+"<br>";
						//msg+="<b>Out </b> Packets:"+out_stats[j].pkts+" Bytes:"+formatBytes(out_stats[j].bytes)+"<br>";
						pkts=Math.abs(out_stats[j].pkts-in_stats[i].pkts);
						bytes=Math.abs(out_stats[j].bytes-in_stats[i].bytes);
					}else if(data.dir=='uni' && out_stats[j].src==data.src){
						pkts=out_stats[j].pkts+in_stats[i].pkts;
						bytes=out_stats[j].bytes+in_stats[i].bytes;}
				}
			}
    }
	for(var i=0;i<in_stats.length;i++){
		pkts_arr.push(in_stats[i].pkts);
		bytes_arr.push(in_stats[i].bytes);
	}
	for(var i=0;i<out_stats.length;i++){
		pkts_arr.push(out_stats[i].pkts);
		bytes_arr.push(out_stats[i].bytes);
	}
	pkts_arr.sort(function(a,b){return b-a;});
	bytes_arr.sort(function(a,b){return b-a});
	//console.log(msg);
	result.pkts=pkts;
	result.bytes=bytes;
	result.bytes_new=bytes_arr[0];
	result.pkts_new=pkts_arr[0];
	result.status=status;
	result.msg=msg;
	return result;
	}
}

function getPacketLossPercentage(data){
	var in_stats=data.more_attributes.in_stats;
	var out_stats=data.more_attributes.out_stats;
	var pkts_bw=0,bytes_bw=0,pkts_diff=0,bytes_diff=0,status=true;
	for(var i=0;i<in_stats.length;i++){
		if(in_stats[i].src==data.src)
			for(var j=0;j<out_stats.length;j++){
					if(out_stats[j].src==data.dst){
						//console.log(out_stats[j].pkts+" and "+in_stats[i].pkts);
						pkts_bw=out_stats[j].pkts+in_stats[i].pkts;
						bytes_bw=out_stats[j].bytes+in_stats[i].bytes;
						pkts_diff=Math.abs(out_stats[j].pkts-in_stats[i].pkts);
						bytes_diff=Math.abs(out_stats[j].bytes-in_stats[i].bytes);
					}
				}
	}
	if((pkts_diff/pkts_bw)*100>10)
		status=false;
	return status;
}
function getBandwidthRange(response){
	var result={};
	var pktslst=new Array();
	var byteslst=new Array();
	for(var i=0;i<response.links.length;i++){
		var src=response.links[i].src;
		var dst=response.links[i].dst;
		var pkts=[];
		var bytes=[];
		if(response.links[i].more_attributes!=undefined){
		var in_stats=response.links[i].more_attributes.in_stats;
		var out_stats=response.links[i].more_attributes.out_stats;
		if((in_stats!=undefined && out_stats !=undefined)){
		for(var j=0;j<in_stats.length;j++){
		    pkts.push(in_stats[j].pkts);
		    bytes.push(in_stats[j].bytes);
		}for(var j=0;j<out_stats.length;j++){
			pkts.push(out_stats[j].pkts);
			bytes.push(out_stats[j].bytes);}
		pkts.sort(function(a,b){return b-a});
		bytes.sort(function(a,b){return b-a});
		pktslst.push(pkts[0]);
		byteslst.push(bytes[0]);
	    }
	   }		
	}
	pktslst.sort(function(a,b){return b-a});
	byteslst.sort(function(a,b){return b-a});
	result['bytes']=byteslst;
	result['pkts']=pktslst;
	return result;
}
function getLinkWidth(bw_max,bw_min,bw){
	//function for scale ((b-a)(x - min)/(max-min))+a;
	var result=1.25;
	if(bw_max==bw){
		result=4.5;
		return result;
	}else if(bw_min==bw || bw_min==undefined || bw_max==undefined){
		result=2.5;
		return result;
    }else if(bw_max!=bw_min){
	var lWidth_min=2.5,lWidth_max=4.5; 
	result=((lWidth_max-lWidth_min)*(bw-bw_min)/(bw_max-bw_min))+lWidth_min;
	if(result<1)
		result=1.25;//Setting min. link width to 1.25, to avoid very thin links
	}
	return result;
}

function reverseString(str) {
    return str.split("").reverse().join("");
}
function parsePortMap(response) {
    var value = 0;
    var portMap = [0,0,0,0,0,0,0,0];
    //var portMap = [0,0,0,0];

    //If portmap received from multiple vRouters
    if((response instanceof Array) && (response[0] instanceof Array)) {
        $.each(response,function(idx,obj) {
            for(var i=0;i<8;i++) {
                portMap[i] |= parseInt(obj[0][i]);
            }
        });
    } else if(response instanceof Array)
        portMap = response;
    if(portMap != null) {
        var strPortMap = [];
        $.each(portMap,function(idx,value) {
            strPortMap.push(reverseString(get32binary(parseInt(value))));
        });
        //console.info(strPortMap);
    }
    //To plot in 4 rows
    var stringPortMap = [];
    for(var i=0,j=0;j<4;i+=2,j++)
        stringPortMap[j] = strPortMap[i] + strPortMap[i+1]
    var chartData = [];
    for(var i=0;i<64;i++) {
      for(var j=0;j<4;j++) {
          chartData.push({
              x:i,
              y:j,
              value:(response == null) ? 0 : parseInt(stringPortMap[j][i])
          });
      }
    }
    return chartData;
}

function parsePortDistribution(result,cfg) {
    var portCF = crossfilter(result);
    var portField = ifNull(cfg['portField'],'sport');
    var flowCntField = ifNull(cfg['flowCntField'],'outFlowCnt');
    var bandwidthField = ifNull(cfg['bandwidthField'],'outBytes');
    var portDim = portCF.dimension(function(d) {return d[cfg['portField']];});
    var PORT_LIMIT = 65536;
    var PORT_STEP = 256;
    var startPort = ifNull(cfg['startPort'],0);
    var endPort = ifNull(cfg['endPort'],PORT_LIMIT);
    if(endPort - startPort == 255)
        PORT_STEP = 1;
    //var PORT_LIMIT = 33400;
    var color;
    if(portField == 'sport') {
        color = d3Colors['green'];
        color = '#1f77b4';
    } else  {
        color = d3Colors['blue'];
        color = '#aec7e8';
    }

    var portArr = [];
    //Have a fixed port bucket range of 100
    for(var i=startPort;i<=endPort;i=i+PORT_STEP) {
        var name,range;
        if(PORT_STEP == 1) {
            portDim.filter(i);
            name =  i;
            range = i;
        } else {
            portDim.filter([i,Math.min(i+PORT_STEP-1,65536)]);
            name =  i + ' - ' + Math.min(i+PORT_STEP-1,65536);
            range = i + '-' + Math.min(i+PORT_STEP-1,65536);
        }
        var totalBytes = 0;
        var flowCnt = 0;
        $.each(portDim.top(Infinity),function(idx,obj) {
            totalBytes += obj[bandwidthField];
            flowCnt += obj[flowCntField];
        });
        var x = Math.floor(i + Math.min(i+PORT_STEP-1,65536))/2
        if(portDim.top(Infinity).length > 0)
            portArr.push({
                x:x,
                y:totalBytes,
                name: name,
                range: range,
                size:flowCnt + 1,
                color:color,
                type:portField
            });
    }
    return portArr;
}

function parseInstDetails(data) {
    var d = data['value'];
    var interfaces = ifNullOrEmptyObject(jsonPath(d,'$..interface_list')[0],[]);
    var intfStr = [];
    var retArr = [];
    var ifStatsList = ifNullOrEmptyObject(jsonPath(d,'$..if_stats_list')[0],[]);
    var floatingIPs = ifNullOrEmptyObject(jsonPath(d,'$..interface_list[*].floating_ips'),[]);
    var floatingIPArr = [];
    //retArr.push({lbl:'vRouter',value:ifNull(jsonPath(d,'$..vrouter')[0],'-')});
    $.each(interfaces,function(idx,obj) {
        var name = obj['name'];
        var currIfStatObj = $.grep(ifStatsList,function(statObj,idx) {
            if(statObj['name'] == obj['name'])
                return true;
            else
                return false;
        });
        intfStr[idx] = wrapLabelValue('IP Address',obj['ip_address']) + wrapLabelValue('Label',obj['label']) + wrapLabelValue('Mac Address',obj['mac_address']) 
            + wrapLabelValue(' Network',obj['virtual_network']); 
        if(currIfStatObj.length > 0) {
            intfStr[idx] += wrapLabelValue('Traffic (In/Out)',formatBytes(currIfStatObj[0]['in_bytes']) + '/' + formatBytes(currIfStatObj[0]['out_bytes']));
        }
        if(obj['gateway'] != null)
            intfStr[idx] += wrapLabelValue('Gateway',obj['gateway']);
        if(idx == 0)
            retArr.push({lbl:'Interfaces',value:intfStr[idx]});
        else
            retArr.push({lbl:'',value:intfStr[idx]});
    });
    //flattenList didn't work as it's not an instance of array
    //$.each(flattenList(floatingIPs),function(idx,obj) {
    $.each(flattenArr(floatingIPs),function(idx,obj) {
        /*if(obj['length'] !=null) {
            $.each(obj,function(idx,currObj) {
                if(currObj['ip_address'] != null)
                    floatingIPArr.push(kendo.format('{0} ({1})',currObj['ip_address'],currObj['virtual_network']));
            });
        } else*/ if(obj['ip_address'] != null)
            floatingIPArr.push(kendo.format('{0} ({1})',obj['ip_address'],obj['virtual_network']));
    });
    if(floatingIPArr.length > 0)
        retArr.push({lbl:'Floating IP',value:floatingIPArr.join(' , ')});
    retArr.push({lbl:'UUID',value:data['name']});
    //retArr.push({lbl:'CPU',value:ifNull(jsonPath(d,'$..cpu_one_min_avg')[0],'-').toFixed(2)});
    retArr.push({lbl:'CPU',value:kendo.toString(ifNull(jsonPath(d,'$..cpu_one_min_avg')[0],'-'),'0.00')});
    var usedMemory = ifNullOrEmptyObject(jsonPath(d,'$..rss')[0],'-');
    var totalMemory = ifNullOrEmptyObject(jsonPath(d,'$..vm_memory_quota')[0],'-');
    if(usedMemory != '-' && totalMemory != '-') {
        if(usedMemory > totalMemory)
            usedMemory = totalMemory;
    }
    retArr.push({lbl:'Memory (Used/Total)',value:formatBytes(usedMemory*1024) + ' / ' + 
        formatBytes(totalMemory*1024)});
    return retArr;
}

function parseNetworkDetails(data) {
    var d = data['value'];
    var retArr = [];
    var connectedNetworks = ifNull(jsonPath(d,'$..UveVirtualNetworkConfig.connected_networks')[0],[]);
    var flowCnt = ifNullOrEmptyObject(jsonPath(d,'$..flow_count')[0],0);
    var policies = ifNullOrEmptyObject(jsonPath(d,'$..attached_policies')[0],[]);
    var policyArr = [];
    $.each(policies,function(idx,obj) {
        policyArr.push(obj['vnp_name']);
    });
    //var partiallyConnectedNetworks = ifNull(jsonPath(d,'$..UveVirtualNetworkConfig.connected_networks')[0],[]);
    retArr.push({lbl:'Connected Networks',value:connectedNetworks.join(', ')});
    retArr.push({lbl:'Flows',value:flowCnt});
    retArr.push({lbl:'ACL',value:ifNullOrEmptyObject(jsonPath(d,'$..acl')[0],'')});
    retArr.push({lbl:'ACL Rules',value:ifNullOrEmptyObject(jsonPath(d,'$..total_acl_rules')[0],0)});
    retArr.push({lbl:'Interfaces',value:ifNullOrEmptyObject(jsonPath(d,'$..interface_list')[0],[]).length});
    //retArr.push({lbl:'Instances',value:ifNull(jsonPath(d,'$..virtualmachine_list')[0],[]).length});
    retArr.push({lbl:'VRF',value:ifNullOrEmptyObject(jsonPath(d,'$..vrf_stats_list[0].name')[0],'')});
    retArr.push({lbl:'Policies',value:policyArr.join(', ')});
    //Remove the label/values where value is empty
    retArr = $.map(retArr,function(obj,idx) {
        if(obj['value'] !== '')
            return obj;
        else
            return null;
    });
    return retArr;
}

function getMultiValueStr(arr) {
    var retStr = '';
    var entriesToShow = 2;
    /*
    if(!(arr instanceof Array)){
    	if($.isEmptyObject(arr))
    		arr = [];
    	else 
    		arr = [arr];
    }*/
    $.each(arr,function(idx,value) {
        if(idx == 0)
            retStr += value; 
        else if(idx < entriesToShow)
            retStr += '<br/>' + value;
        else
            return;
    });
    if(arr.length > 2)
        retStr += '<br/>' + kendo.format('({0} more)',arr.length-entriesToShow);
    return retStr;
}

function getIANAServiceForPort(protNo,portNo) {
    var ianaMap = {'443':'HTTPS','80':'HTTP','23':'Telnet','22':'SSH'};
    var protMAP = {'17':'UDP','6':'TCP','2':'IGMP','0':'ICMP'}
    var retStr = '';
    /*if(protNo == 1 && portNo == 0)
        return 'ICMP';*/
    if(portNo in ianaMap) {
        return ianaMap[portNo] + ' (' + portNo + ')';
    } else
        return portNo;
}
function getProtocolName(protNo) {
    var protMAP = {'17':'UDP','6':'TCP','2':'IGMP','0':'ICMP'}
    if(protNo in protMAP)
        return protMAP[protNo];
    else
        return protNo;
}
